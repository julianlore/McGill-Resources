% Created 2017-11-14 Tue 12:45
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 25.3.1 (Org mode 9.1.2)}, 
 pdflang={English}}
\begin{document}

\tableofcontents

\section{Lecture 1 \textit{<2017-09-12 Tue>}}
\label{sec:org0af0e34}
This course is an introduction to the foundations and paradigms of programming languages.
\begin{itemize}
\item 5 assignments, 5\% each
\item 10\% midterm
\item 65\% final
\item You have two late days for the semester (cumulative)
\end{itemize}
\subsection{Four main goals of COMP 302}
\label{sec:orgfa84907}
\begin{enumerate}
\item Provide thorough introduction to fundamental concepts in programming languages
\begin{itemize}
\item Higher-order functions
\item State-full vs state-free computation (most languages like Java we've seen are state-full)
\item Modeling objects and closures
\item Exceptions to defer control
\item Continuations to defer control
\item Polymorphism
\item Partial evaluation
\item Lazy programming
\item Modules
\item Etc.
\item Want to explore these concepts so you can recognize them in another language you study at some point
\end{itemize}
\item Show different ways to reason about programs
\begin{itemize}
\item Type checking
\begin{itemize}
\item One of the best inventions
\item Checks what it expects and will actually tell you where it expects something
\item Program is more likely to be correct now
\end{itemize}
\item Induction
\begin{itemize}
\item Proving a program/transformation correct
\end{itemize}
\item Operational semantics
\begin{itemize}
\item How a program is executed
\end{itemize}
\item QuickCheck
\end{itemize}
\item Introduce fundamental principles in programming language design
\begin{itemize}
\item Grammars
\item Parsing
\item Operational semantics and interpreters
\item Type checking
\item Polymorphism
\item Subtyping
\end{itemize}
\item Expose students to a different way of thinking about problems
\begin{itemize}
\item It's like going to the gym; it's good for you!
\end{itemize}
\end{enumerate}
\subsubsection{How we achieve these goals}
\label{sec:org4289872}
\begin{itemize}
\item Functional programming in OCaml
\begin{itemize}
\item Equal playing field
\begin{itemize}
\item No one in the class really knows it, not affected by performance in previous classes like 250
\end{itemize}
\item Allows us to explain and model object-oriented and imperative programming
\begin{itemize}
\item Isolates lots of the concepts individually
\end{itemize}
\item Isolates concepts such as state-full vs state-free, modules and functions, etc.
\item Statically typed language enforces disciplined programming
\begin{itemize}
\item Also demonstrates that types are an important maintenance tool
\end{itemize}
\item Easy to reason about runtime behavior and cost
\end{itemize}
\end{itemize}
\subsubsection{Guiding Principles}
\label{sec:orgedadb25}
\begin{itemize}
\item No point in learning a programming language unless it changes how you view programming
\item Simple and elegant solutions are more effective, but harder to find than the complicated ones, take more time.
\begin{itemize}
\item You spend very little time testing OCaml code and more time compiling it
\end{itemize}
\end{itemize}

\subsubsection{Why do I need to know this}
\label{sec:org17731d9}
\begin{itemize}
\item Science and craft of programming
\item Skills you learn will help you become a better programmer
\begin{itemize}
\item More productive
\item Code easier to maintain and read
\item Etc.
\end{itemize}
\item Will be needed in some upper level courses
\begin{itemize}
\item Like compilers, etc.
\end{itemize}
\item It is cool and fun!
\item You might even get a job!
\end{itemize}

\subsection{Assignments}
\label{sec:orgcca3e83}
\begin{itemize}
\item Can do assignments in groups of 2
\end{itemize}

\subsection{Misc}
\label{sec:org3e98508}
\begin{itemize}
\item Lectures won't be recorded.
\item Slides may or may not be posted, but there are lecture notes on MyCourses (most essential reading)
\end{itemize}
\section{Lecture 2 \textit{<2017-09-14 Thu>}}
\label{sec:org7df5587}
\subsection{What is OCaml}
\label{sec:org2c82afc}
\begin{itemize}
\item Statically typed functional programming language
\end{itemize}
\subsubsection{Statically typed}
\label{sec:org2f550e5}
\begin{itemize}
\item Types approximate runtime behavior
\item Analyze programs before executing them
\item Find a fix bugs before testing
\item Tries to rule out bad scenarios
\item Very efficient, very good error messages, very good maintenance tool
\end{itemize}
\subsubsection{Functional}
\label{sec:orga7bbffc}
\begin{itemize}
\item Primary expressions are functions!
\item Functions are first-class!
\begin{itemize}
\item Not only can we return base types like ints, we can return functions and pass them as arguments too
\item One of the key features of functional languages
\end{itemize}
\item Pure vs Not Pure languages
\begin{itemize}
\item Haskell is Pure
\begin{itemize}
\item Doesn't give you ways to allocate memory or directly modify memory
\end{itemize}
\item OCaml is impure
\begin{itemize}
\item Has arrays and consequences and stuff
\end{itemize}
\end{itemize}
\item Call-By-Value vs Lazy
\begin{itemize}
\item OCaml is call by value
\end{itemize}
\end{itemize}
\subsubsection{Concepts for Today}
\label{sec:orgd1e19eb}
\begin{itemize}
\item Writing and executing basic expressions
\item Learn how to read error messages
\item Names
\end{itemize}
\subsubsection{OCaml demo in class}
\label{sec:orgc97f878}
\begin{itemize}
\item Always have to finish a line with 2 semi colons ;;
\item Can use interpreter by launching OCaml in shell
\item Functional good for parallel computing
\item Good to reason about these programs
\item int: 
\begin{itemize}
\item 1 ;;
\item 1+3;;
\end{itemize}
\item Strings: 
\begin{itemize}
\item "Hello";;
\end{itemize}
\item Floats:
\begin{itemize}
\item 3.14;;
\end{itemize}
\item Booleans:
\begin{itemize}
\item true;;
\end{itemize}
\item if
\begin{itemize}
\item if 0=0 then 1.4 else 2.1 ;;
\end{itemize}
\end{itemize}
\begin{enumerate}
\item Operators
\label{sec:org1ae4443}
\begin{itemize}
\item +, -, /, *
\begin{itemize}
\item Take as input 2 int, return int
\end{itemize}
\item 3.14 + 1 ;; \(\to\) error
\item To specify for floating point operators, follow by a dot. Only works with floating points, no ints
\begin{itemize}
\item 3.14 +. 2.4 ;;
\end{itemize}
\end{itemize}
\item Types
\label{sec:org7dd1ca7}
\begin{itemize}
\item Approximate the runtime behaviour
\item Types classify expressions according to the value they will compute
\item Won't execute right away, will think of types you are returning to see if it's valid
\item if 0=0 then 1.4 else 3 ;; 
\begin{itemize}
\item Error, after reading 1.4 expects 3 to be float
\end{itemize}
\item if bool then T else T
\begin{itemize}
\item Both Ts have to be the same type
\end{itemize}
\item Type checker will allow 1/0;; to run, but will have a runtime exception
\begin{itemize}
\item int/int is not enough info to know that your dividing by 0
\end{itemize}
\end{itemize}
\item Vars
\label{sec:org683bcc6}
\begin{itemize}
\item let pi = 3.14 ;;
\item let (pi : float) = 3.14 ;;
\item let m = 3 in
\begin{itemize}
\item let n=m * m in
\item let k=m*m in
\item k*n ;;
\end{itemize}
\end{itemize}
\item Binding
\label{sec:org5ddc44d}
\begin{itemize}
\item let m = 3 ;; puts it on the stack
\item let m = 3 in \ldots{}
\begin{itemize}
\item m is a local variable now (temporary binding), once you hit ;;, won't have m anymore
\item Garbage collector
\end{itemize}
\item let x (name of a variable) = exp in \uline{exp} (x is bound to this expression)
\item variables are bind to values, not assigned values
\begin{itemize}
\item they look in the past!
\end{itemize}
\end{itemize}

\item Functions
\label{sec:orgc89a3bf}
\begin{itemize}
\item let area = function r -> pi *. r * .r;;
\begin{itemize}
\item Syntax error
\end{itemize}
\item let area = function r -> pi *. r *. r ;;
\item let area r = pi *. r *. r ;;
\item let a4 = area (2.0);;
\item If you redefine pi, like let pi = 6.0 ;;
\item area(2.0) will still give you the same thing
\item The function looks up in the past

\item Stack:
\end{itemize}
\begin{center}
\begin{tabular}{lr}
 & \\
\hline
pi & 6.0\\
area & function r -> p *. r *. r\\
k & 5\\
k & 4\\
pi & 3.14\\
\end{tabular}
\end{center}

\begin{itemize}
\item Can redefine the function though
\end{itemize}
\end{enumerate}
\section{Lecture 3 \textit{<2017-09-15 Fri>}}
\label{sec:org32fc432}
\subsection{Functions}
\label{sec:org0a27a04}
\begin{itemize}
\item Functions are values
\item Function names establish a binding of the function name to its body
\begin{itemize}
\item let area (r:float)=pi*. r *. r ;;
\end{itemize}
\end{itemize}
\subsubsection{Recursive functions}
\label{sec:org4490919}
Recursive functions are declared using the keyword \uline{let rec}
\begin{itemize}
\item let rec fact n =
\begin{itemize}
\item if m = 0 them 1
\begin{itemize}
\item else n*face(n-1)
\end{itemize}
\end{itemize}
\item fact 2 needs to be stored on the stack
\item fact 2 -> 2* fact 1
\item fact 1 -> 1* fact 0 stored on stack
\item fact 0 = 1
\item Need to remember computation when you come back out of recursion, so need to store on the stack
\begin{itemize}
\item What's the solution to this? How is functional programming efficient?
\end{itemize}
\end{itemize}
\begin{enumerate}
\item Tail-recursive functions
\label{sec:org17cb122}
A function is said to be "tail-recursive", if there is nothing to do except return the final value. Since the execution of the function is done, saving its stack frame (i.e. where we remember the work we still in general need to do), is redundant
\begin{itemize}
\item Write efficient code
\item All recursive functions can be translated into tail-recursive form
\end{itemize}
\item Ex. Rewrite Factorial
\label{sec:org212833d}
\begin{itemize}
\item let rec fact\_tr n =
\begin{itemize}
\item let rec f(n,m) -
\begin{itemize}
\item if n=0 then
\begin{itemize}
\item m
\end{itemize}
\item else f(n-1,n*m)
\end{itemize}
\item in
\begin{itemize}
\item f(n,1)
\end{itemize}
\end{itemize}

\item Second parameter to accumulate the results in the base case we simply return its result

\item Avoids having to return a value from the recursive call and subsequently doing further computation

\item Avoids building up a runtime stack to memorize what needs to be done once the recursive call returns a value

\item f(2,1) -> fact(1, 2*1) -> fact(0,2)-> 2

\item Whoever uses the function does not need to know how the function works, so you can use this more efficient way in the background

\item What is the type of fact\_tr? fact\_tr: int(input) \(\to\) int(output)

\item Type of f? f: int * int (tuple input) \(\to\) int

\begin{itemize}
\item n-tuples don't need to be of the same type, can have 3 different types, like int*bool*string
\end{itemize}
\end{itemize}
\end{enumerate}
\subsubsection{Passing arguments}
\label{sec:org4e642f9}
\begin{itemize}
\item ' means any type, i.e. 'a
\item All args at same time
\begin{itemize}
\item 'a*'b -> 'c
\end{itemize}
\item One argument at a time
\begin{itemize}
\item 'a -> 'b -> 'c
\item May not have a and b at the same time. Once it has both it will get c.
\end{itemize}
\item We can translate any function from one to the other type, called currying (going all at once to one at a time) and uncurrying (opposite).
\begin{itemize}
\item Will see in 2 weeks
\end{itemize}
\end{itemize}
\subsection{Data Types and Pattern Matching}
\label{sec:org4be99a9}
\subsubsection{Playing cards}
\label{sec:org322ad66}
\begin{itemize}
\item How can we model a collection of cards?
\item Declare a new type together with its elements
\item type suit = Clubs | Spades | Hearts | Diamonds
\begin{itemize}
\item Called a user-defined (non-recursive) data type
\item Order of declaration does not matter
\begin{itemize}
\item Like a set
\end{itemize}
\item We call clubs, spades, hearts, diamonds constructors (or constants), also called elements of this type
\begin{itemize}
\item \uline{Constructors} must begin with a \uline{capital letter} in OCaml
\end{itemize}
\end{itemize}
\item Use \uline{pattern matching} to analyze elements of a given type.
\item match <expression> with
\begin{center}
\begin{tabular}{l}
<pattern> -> <expression>\\
<pattern> -> <expression>\\
\end{tabular}
\end{center}
\ldots{}
\begin{center}
\begin{tabular}{l}
<pattern> -> <expression>\\
\end{tabular}
\end{center}
\end{itemize}
A pattern is either a variable or a \ldots{}
\begin{itemize}
\item Statements checked in order
\end{itemize}
\begin{enumerate}
\item Comparing suits
\label{sec:org6700e51}
Write a function dom of type suit*suit -> bool
\begin{itemize}
\item dom(s1,s2) = true iff suit s1 beats or is equal to suit s2 relative to the ordering Spades > Hearts > Diamonds > Clubs
\item (Spades, \_) means Spades and anything
\item (s1, s2) -> s1=s2 will return the result of s1=s2
\item Compiler gives you warning if it's not exhaustive and tells you some that aren't matched
\end{itemize}
\end{enumerate}
\section{Lecture 4 \textit{<2017-09-19 Tue>}}
\label{sec:org4ba8ea2}
\subsection{Data Types and Pattern Matching Continued}
\label{sec:orgae98c62}
\begin{itemize}
\item Type is unordered
\item type suit = Clubs | Spades | Hearts | Diamonds
\begin{itemize}
\item Order doesn't matter here, but they must start with capitals
\end{itemize}
\item type rank = Two | Three | \ldots{}
\item type card = rank * suit
\end{itemize}
What is a hand? A hand is either empty or if c is a card and h is a hand then Hand(c,h). Nothing else is a hand. Hand is a constructor. hand is a type. (capitalization mattersA)
\begin{itemize}
\item Recursive user defined data type
\item Inductive or recursive definition of a hand
\begin{itemize}
\item Add a card to something that is a hand, still a hand
\end{itemize}
\end{itemize}
\subsubsection{Recursive data type}
\label{sec:org8f7f4a5}
\begin{itemize}
\item type hand = Empty | Hand of card * hand
\end{itemize}
\begin{enumerate}
\item Typing into interpreter
\label{sec:org1e82491}
\begin{itemize}
\item Empty;;
\begin{itemize}
\item hand = Empty
\end{itemize}
\item let h1 = Hand ((Ace, Spades),Empty);;
\begin{itemize}
\item Want only 1 card, so include empty
\item Recursive data type, so it needs another hand in it
\end{itemize}
\item let h2 = Hand ((Queen, Hearts), Hand((Ace,Spades), Empty);;
\begin{itemize}
\item Recursive
\end{itemize}
\item let h3 = Hand ((Joker, Hearts), h2) ;;
\begin{itemize}
\item Error, Joker not defined
\end{itemize}
\item type 'a list = Nil | Cons of 'a * 'a list
\item Hand ((Queen, Hearts), (King, Spades), (Three, Diamonds));;
\begin{itemize}
\item Hand has type? card * card * card
\item Get an error, because constructor Hand expects 2 arguments (card+hand)
\end{itemize}
\end{itemize}
\end{enumerate}
\subsubsection{Extract Example}
\label{sec:org138a675}
\begin{itemize}
\item Given a hand, extract all cards of a certain suit
\item extract: suit -> hand -> hand
\end{itemize}

\begin{verbatim}
let rec extract (s:suit) (h:hand) = match h with
  | Empty -> Empty (* We are constructing results, not destructing given hand *)
  (* Want to extract suit from first card *)
  | Hand ( (r0.s0) ,h) -> 
     (*Make a hand with first card and remaining results of recursive ext*)
     if s0 = s then Hand( (r0, s0), extract s h0)
     else extract s h0
\end{verbatim}
Hand is "destroyed" through this method, but old hand stays the same, it is not modified.
\begin{itemize}
\item Running extract Spades hand5;; will give a new hand with only spades
\item Good exercise, write a function that counts how many cards in the hand
\item Can we make this thing tail recursive?
\end{itemize}

\begin{verbatim}
let rec extract' (s:suit) (h:hand) acc = match h with
  | Empty -> acc (* Accumulator *)
  (* Want to extract suit from first card *)
  | Hand ( (r0.s0) ,h) -> 
     (*Make a hand with first card and remaining results of recursive ext*)
     if s0 = s then extract' s h0 (Hand( (r0, s0), acc))
     else extract' s h0 acc
\end{verbatim}

\begin{itemize}
\item extract' Spades hand5 Empty ;;
\item Gives same cards but in the reverse order of extract
\item extract Spades hand5 = extract' Spades hand5 Empty ;;
\begin{itemize}
\item False
\end{itemize}

\item Write a function find which when given a rank and a hand, finds the first card in hand of the specified rank and returns its corresponding suit.
\end{itemize}
What if no card exists?
\begin{itemize}
\item Optional Data Type (predefined)
\item type 'a option = None | Some of 'a
\end{itemize}
\section{Lecture 5 \textit{<2017-09-21 Thu>}}
\label{sec:org0acb6a2}
\begin{verbatim}
(* type mylist = Nil | Cons of ? * list;; *)
(* Polymorphic lists:  *)
(* type 'a mylist = Nil | Cons of 'a * 'a my list *)
[] ;;
1 :: [] ;;
1 :: 2 :: 3 :: [] ;;
[1;2;3;4];;

(* These are only homogenous lists though, what if we want floats and ints? *)
(* type if_list = Nil | ICons of int * if_list | FCons of float * if_list *)
(* But here we can't use List libraries *)

(* So make an element that can be either *)
type elem = I of int | F of float;;

let rec append l1 l2 = match l1 with
  | [] -> l2
  | x::xs -> x :: append xs l2;;
(* Program execution *)
(* append 1::(2::[]) -> 1 :: append (2::[])             *)
let head l = match l with
  | [] -> None
  | x :: xs -> Some x;;

(* Write a function rev given a list l of type 'a list returns it's reverse  *)

(* Silly way of doing this             *)
let rec rev (l : 'a list) = match l with
  | [] -> []
  | hd :: tail -> rev (tail) @ [hd];;
(* Could we have written rev(tail) :: hd? No. Why? *)
(* a' : 'a list, left side has to be one element, right side  to be a list *)
(* 'a list @ 'alist *)

(* What is the type of rev? Is it 'a list? -No *)
(* It is 'a list -> 'a list *)

(* Is this a good program? Long running time, use tail recursion  *)


let rev_2 (l : 'a list) =  
  let rec rev_tr l acc = match l with
    | [] -> acc
    | h::t -> rev_tr t (h::acc)
  in
  rev_tr l [];;

(* Exercises:
 * Write a function merge: 'a list -> 'a list -> 'a list
which given ordered lists l1 and l2, both of type 'a list,
it returns the sorted combination of both lists 
 * Write a function split: 'a list -> 'a list * 'a list 
which given a list l it splits into two sublists, 
(every odd element, every even element)*)
\end{verbatim}
\subsection{Lists}
\label{sec:orgb8d82a2}
What are lists?
\begin{itemize}
\item Nil([]) is a list
\item Given an element x and a list l x::l is a list
\item Nothing else is a list
\item\relax [] is an \('\alpha\) list
\begin{itemize}
\item Given an element x of type \('\alpha\) and l of type \('\alpha\) list
\item[{x}] l is an \('\alpha\) list (i.e. a list containing elements of type \('\alpha\))
\end{itemize}
\item ; are syntactical sugar to separate elements of a list
\end{itemize}
\subsection{Execution}
\label{sec:org67a2a94}
Understand how a program is executed
\begin{itemize}
\item \textbf{Operational Semantics}
\end{itemize}
\section{Lecture 6 \textit{<2017-09-22 Fri>}}
\label{sec:orgfc801ba}
\subsection{Proofs}
\label{sec:orgff2d308}
\subsubsection{Demo: lookup \& insert}
\label{sec:org58d826e}
\begin{verbatim}
(* Warm up *)
(* Write a function lookup: 'a -> ('a * 'b) list -> 'b option. 
Given a key k of type 'a and a list l of key-value pairs, 
return the corresponding value v in l (if it exists). *)
(* lookup : 'a -> ('a * 'b) list -> 'b option  *)
let rec lookup k l = match l with
  | [] -> None
  | (k',v')::t -> if k=k' then Some v' (* If it is the right key, return val*)
		  else lookup k t;;

(* Write a function insert which
given a key k and a value v and an ordered list l of type ('a * 'b) list
it inserts the key-value pair (k,v) into the list l 
preserving the order (ascending keys). *)
(* insert : ('a * 'b) -> ('a * 'b) list -> ('a * 'b) list 
 insert (k,v) l = l'

 Precondition: l is ordered.

Postcondition: l' is also ordered and we inserted (k,v) at the right position in l*)

(* let rec insert (k,v) l = match l with
 *   | [] -> [(k,v)]
 *         (\* k = k' or k < k' or k' < k *\)
 *   | ((k',v') as h) :: t ->
 *      if k = k' then (k,v) :: l
 *      else
 *        if k' < k then (k,v) :: l
 *        else h :: insert (k,v) t;;
 * 
 * let l = [(1,"anne") ; (7,"di")];;
 * l;;
 * let l0 = insert (3,"bob") l;;
 * insert (3,"tom") l0 ;;
 * (\* But now we'll have 2 entries with the same key *\) *)
(* Undesirable, better to replace the value if its a dictionary*)

let rec insert (k,v) l = match l with
  | [] -> [(k,v)]
	(* k = k' or k < k' or k' < k *)
  | ((k',v') as h) :: t ->
     if k = k' then (k,v) :: t (* Replace *)
     else
       if k' < k then (k,v) :: l
       else h :: insert (k,v) t;;

(* Personal tail recursive attempt *)
let insert_t (k,v) l =
  let rec insert_acc (k,v) l acc = match l with
    | [] -> acc @ [(k,v)]
    | ((k',v') as h) :: t ->
       if k = k' then (k,v) :: t
       else
	 if k' < k then (k,v) :: l
	 else insert_acc (k,v) t (acc @ [h])
\end{verbatim}
\begin{itemize}
\item What is the relationship between lookup and insert?
\end{itemize}
\subsubsection{How to prove it?}
\label{sec:org17c9b30}
\begin{enumerate}
\item Step 1
\label{sec:org72df7b7}
We need to understand how programs are executed (operational semantics)
\begin{itemize}
\item \(e \Downarrow v\) expression \(e\) evaluates in multiple steps to the value \(v\). (\textbf{Big-Step})
\item \(e \Rightarrow e'\) expression \(ee\) evaluates in one steps to expression \(e'\). (\textbf{Small-Step (single)})
\item \(e \implies^* e'\) expression \(e\) evaluates in multiple steps to expression \(e'\) (\textbf{Small-Step (multiple)})
\end{itemize}

For all l, v, k, lookup k (insert k v l) \(\implies *\) Some v
Induction on what?
\item Step 2
\label{sec:org8c3438c}
\(P(l) = lookup k\) (insert\((k,v) l\)) \(\Downarrow\) Some \(v\)
\begin{itemize}
\item How to reason inductively about lists?
\begin{itemize}
\item Analyze their structure!
\item The recipe \ldots{}
\item To prove a property \(P(l)\) holds about a list \(l\)
\begin{itemize}
\item Base Case: \(l = []\)
\begin{itemize}
\item Show \(P([])\) holds
\end{itemize}
\item Step Case: \(l=x::xs\)
\begin{itemize}
\item IH \(P(xs)\) (Assume the property \(P\) holds for lists smaller than \(l\))
\end{itemize}
\item Show \(P(x::xs)\) holds (Show the property \(P\) holds for the original list \(l\))
\end{itemize}
\end{itemize}
\end{itemize}
\item Theorem
\label{sec:org666315e}
For all \(l, v, k\), lookup \(k\) (insert \((k,v) l\)) \(\implies *\) Some \(v\)
\item Proof
\label{sec:orge934243}
Proof by structural inductional on the list \(l\)
\begin{itemize}
\item Case: \(l = []\)
\begin{itemize}
\item lookup k (insert(k,v)[])
\item \(\stackrel{\text{By insert program}}{\implies}\) lookup k [(k,v)] (same as (k,v)::[]) \(\stackrel{\text{By lookup}}{\implies}\) Some \(v\)
\begin{itemize}
\item Would not hold if we didn't put the k=k case
\end{itemize}
\end{itemize}
\item Case: \(l=h::t\) where \(h=(k',v')\)
\begin{itemize}
\item IH: For \(k,v\) lookup \(k\) (insert (k,v) t) \(\Downarrow\) Some \(v\)
\item To show: lookup k (insert (k,v)) \(\underbrace{(k',v')::t}_l \Downarrow\) Some \(v\)
\item Subcase: \(k=k'\)
\begin{itemize}
\item lookup k (insert (k,v) ((k', v')::t))
\item \(\stackrel{\text{By insert}}{\implies}\) lookup k ((k,v)::t)
\item \(\stackrel{\text{By lookup}}{\implies}\) Some v (good)
\end{itemize}
\item Subcase: \(k<k'\)
\begin{itemize}
\item lookup k (insert(k,v) ((k',v'):: t))
\item \(\stackrel{\text{By insert}}{\implies}\) lookup k ((k,v)::l)
\item \(\stackrel{\text{By lookup}}{\implies}\) Some v (good)
\end{itemize}
\item Subcase: \(k>k'\)
\begin{itemize}
\item lookup k (insert(k,v) ((k',v')::t))
\item \(\stackrel{\text{By insert}}{\implies}\) lookup k ((k', v')::insert (k,v) t)
\item \(\stackrel{\text{By lookup}}{\implies}\) lookup k (insert (k,v) t)
\item \(\stackrel{\text{By IH}}{\implies}\) Some \(v\)
\end{itemize}
\end{itemize}
\end{itemize}
\item Lesson to take away
\label{sec:org833ed1f}
\begin{itemize}
\item State what you are doing induction on
\begin{itemize}
\item Proof by structural induction in the list l
\end{itemize}
\item Consider the different cases!
\item For lists, there are two cases- either l =[] or l = h::t
\item State your induction hypothesis
\begin{itemize}
\item IH: For all v,k, lookup insert (k,v) t \(\Downarrow\) Some \(v\)
\end{itemize}
\item Justify your evaluation / reasoning steps by
\begin{itemize}
\item Referring to evaluation of a given program
\item The induction hypothesis
\item Lemmas/ Properties (such as associativity, commutativity)
\end{itemize}
\end{itemize}
\end{enumerate}
\section{Lecture 7 \textit{<2017-09-26 Tue>}}
\label{sec:orgb7d46e3}
\subsection{Structural Induction}
\label{sec:org3f95234}
\begin{itemize}
\item How do I prove that all slices of cake are tasty using structural induction?
\begin{itemize}
\item Define a cake slice recursively
\item Prove that a single piece of cake is tasty
\item Use recursive definition of the set to prove that all slices are tasty
\item Conclude all are tasty
\end{itemize}
\end{itemize}
\subsubsection{Example with rev}
\label{sec:orga870eaa}

\begin{verbatim}
(* naive *)
(* rev: 'a list -> 'a list *)
let rec rev l = match l with
| [] -> []
| x::l -> (rev l) @ [x];;

(* tail recursive *)
(* rev': 'a list -> 'a list *)
let rev' l =
(* rev_tr: 'a list -> 'a list -> 'a list *)
let rec rev_tr l acc = match l with
| [] -> acc
| h::t -> rev_tr t (h::acc)
in
rev_tr 1 [];;

(* Define length *)
let rec length l = match l with
| [] -> 0
| h::t -> 1+length t  
\end{verbatim}
\begin{enumerate}
\item Theorem:
\label{sec:org367b8f4}
For all lists l, rev l = rev' l.

What is the relationship between l, acc and rev\_tr l acc?

\begin{itemize}
\item Invariant of rev
\begin{itemize}
\item length l = length (rev l)
\end{itemize}
\item Invariant rev\_tr
\begin{itemize}
\item length l + length acc = length(rev\_tr l acc)
\end{itemize}
\item How are these related?
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
\begin{itemize}
\item rev l \(\Downarrow\)
\item rev\_tr l acc \(\Downarrow\) v
\item Not quite because:
\begin{itemize}
\item rev [] \(\Downarrow\) []
\item rev\_tr [] acc \(\Downarrow\) acc
\item Not returning the same thing given empty list
\end{itemize}
\item Slightly modified so it's right:
\begin{itemize}
\item rev l @ acc \(\Downarrow\) v
\item rev\_tr l acc \(\Downarrow\) v
\end{itemize}
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}

For all l, acc, (rev l) @ acc \(\Downarrow\) v and rev\_tr l acc\(\Downarrow\) v
By induction on the list l.
\begin{itemize}
\item Case l=[]
\begin{itemize}
\item rev [] @ acc
\item \(\stackrel{\text{prog rev}}{\rightarrow}\) [] @ acc \(\rightarrow\) acc
\item rev\_tr [] acc
\item \(\stackrel{\text{by prog rev\_tr}}{\rightarrow}\) acc
\end{itemize}
\item Case \(l=h::t\)
\begin{itemize}
\item \textbf{IH: For all acc rev t @ acc \(\Downarrow\) v and rev\_tr t acc \(\Downarrow\) v}
\item rev (h::t) @ acc \(\stackrel{\text{by rev}}{\rightarrow}\) (rev t @ [h])@acc
\begin{itemize}
\item \(\stackrel{\text{By associativity of @}}{\rightarrow}\) rev t @ ([h] @ acc)
\item \(\stackrel{\text{@}}{\rightarrow}\) rev t @ (h::acc)
\end{itemize}
\item rev\_tr (h::t) acc \(\rightarrow\) rev\_tr t (h::acc)
\item By the IH rev t @ (h::acc) \(\Downarrow\) v and rev\_tr t (h::acc) \(\Downarrow\) v
\end{itemize}
\end{itemize}
\end{enumerate}
\subsection{Trees}
\label{sec:orgc68b6ed}
\begin{verbatim}
type 'a tree = Empty | Node of 'a = 'a tree * 'a tree;;
let t0 = Node (5, Node (3, Empty, Empty), Empty);;
(* 5 is at the head, has 3 as left child, all other children are empty *)

let rec size t = match t with
  | Empty -> 0
  | Node (v, l, r) -> 1 + size l + size r

				     size t0;;
(* Since Ocaml is a stack, 
  if you modify the tree type after declaring t0,
  then t0 will be the old type, 
  so when you try to use size you'll get an error 
  as it's not the same type *)

type 'a forest = Forest of ('a many_trees) list
and 'a many_trees = Empty | MoreTrees of 'a many_trees

(* Mutually recursive *)

let rec size_forest f = match f with
  | Forest trees -> match trees with
		    | [] -> 0
		    | h::t -> size_many_trees h + size_forest (Forest t) 

and size_many_trees t = match t with
  | NoTree -> 0
  | MoreTrees f -> 1 + size_forest f
\end{verbatim}
\section{Lecture 8 \textit{<2017-09-28 Thu>}}
\label{sec:orgdab648e}
\subsection{Binary Tree (Inductive definition)}
\label{sec:org2c5ae51}
\begin{itemize}
\item The empty binary tree empty is a binary tree
\item If l and r are binary trees and v is a value of type 'a then Node(v, l, r) is a binary tree
\item Nothing else is a binary tree
\end{itemize}

How to define a recursive data type for trees in OCaml?

\begin{verbatim}
type 'a tree =
Empty
| Node of 'a * 'a tree * 'a tree |
\end{verbatim}
\subsection{Insert}
\label{sec:org6951980}
Want to make a function insert
\begin{itemize}
\item Given as input (x,dx), where x is key and dx is data and a binary search tree t
\begin{itemize}
\item Return a binary search tree with (x,dx) inserted
\item What is insert's type?
\begin{itemize}
\item (a' * b') \(\to\) ('a \(\times\) 'b)tree \(\to\) ('a \(\times\) 'b) tree
\end{itemize}
\end{itemize}
\item Good exercise: write a function to check if a tree is a binary search tree or not
\begin{itemize}
\item Good exam question
\end{itemize}
\end{itemize}

\begin{verbatim}
(* Data Types: Trees *)

type 'a tree = Empty | Node of 'a * 'a tree * 'a tree

let rec size t = match t with
  | Empty -> 0
  | Node (v, l, r) -> 1 + size l + size r 
let rec insert ((x,dx) as e) t = match t with
  (* Tree is empty, root is now e *)
  | Empty -> Node (e, Empty, Empty)
  | Node ( (y,dy), l, r) ->
     (* Replace val that has same key *)
     (* No destructive updates, need to keep elements and remake tree *)
     if x = y then Node (e, l, r)
			(* Go down left tree *)
     else (if x < y then Node ( (y,dy), insert e l, r)
			      (* Go down right tree *)
	   else Node ((y,dy), l, insert e r)
	  )

	    (* Can we still use these less than signs for any type? 
	     The node constructor uses any type
	     Since we used comparison, we can*)

;;
3 < 4 ;;
Empty < Node (3, Empty, Empty);;
Node (3, Empty, Empty) < Node (4, Empty, Empty) ;;

[3 ; 4] < [2 ; 5];;
(* Why is this false? *)

[3 ; 5] < [4 ; 7];;
[3 ; 5] < [7];;
(* Doesn't look at length of list, looks at first number of list *)
(* Dangerous to have comparison on all these types. Can only compare built in data types (for lists here, it's comparing ints) 
 OCaml will come up with something, but it might not be the correct thing
 For example, with the suits example we made a function to quantify
 what's bigger*)

(* lookup: 'a -> ('a x 'b)tree -> b' option *)
(* Option in case key isn't there *)
let rec lookup x t = match t with
  | Empty -> None
  | Node ( (y, dy), l, r) ->
     if x = y then Some dy
     else ( if x < y then
	      lookup x l
	    else lookup x r
	  )
;;


(* collect: 'a tree -> 'a list 
 What order do we want to return it in? In order traversal*)
let rec collect t = match t with
  | Empty -> []
  | Node (x, l, r) ->
     let l1 = collect l in
     let l2 = collect r in
     l1 @ l2
(* Incomplete, where to put x? *)
;;

collect (Node (5, Node (3, Empty, Empty), Empty));;
\end{verbatim}

\subsection{Proving}
\label{sec:orga54aab8}
\begin{itemize}
\item How to reason inductively about trees? Analyze their structures!
\end{itemize}

\subsection{Theorem}
\label{sec:org4d82753}
For all trees t, keys x, and data dx, lookup x(insert (x, dx) t) \(\Rightarrow*\) Some dx
\subsubsection{Proof by structural induction on the tree t}
\label{sec:org03a61ce}
(You get points on an exam for mentioning what kind of induction, structural induction on tree, points for base case/case, points for stating induction hypothesis, perhaps multiple. Then show by a sequence of steps of how to get from what to show to the end)
\begin{itemize}
\item Case t = Empty
\begin{itemize}
\item lookup x (insert (x, dx) Empty) \(\stackrel{\text{By insert}}{\Rightarrow}\) lookup x (Node ((x,dx), Empty, Empty)) \(\stackrel{\text{by lookup}}{\Rightarrow}\) Some dx
\end{itemize}
\item Case t = Node ( (y,dy), l, r)
\begin{itemize}
\item Both trees l and r are smaller than t
\item IH1: For all x, dx, lookup x (insert (x,dx) l) \(\Rightarrow*\) Some dx
\item IH2: For all x, dx, lookup x (insert(x,dx) r) \(\Rightarrow*\) Some dx
\end{itemize}
\item Need to show lookup x (insert (x, dx) Node ((y, dy), l, r))
\item Show 3 cases (x < y, x = y, y < x)
\begin{itemize}
\item x < y \(\Rightarrow\) lookup x (Node((y,dy), insert (x,dx) l, r)) \(\stackrel{\text{By lookup}}{\Rightarrow}\) lookup x (insert (x,dx) l) \(\stackrel{\text{by IH 1}}{\Rightarrow}\) Some dx
\item x=y lookup x(insert (x,dx) Node ((y, dy), l, r)) \(\stackrel{\text{by ins}}{\Rightarrow}\) lookup x (Node ((x,dx), l, r)) \(\stackrel{\text{by lookup}}{\Rightarrow}\) Some dx
\end{itemize}
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
Exercise: write a type for cake (2 slice of cake together become 1 slice), with weight
\section{Lecture 9 \textit{<2017-09-29 Fri>}}
\label{sec:org126cf92}
\subsection{Higher-order functions}
\label{sec:org4d57823}
\begin{itemize}
\item Allows us to abstract over common functionality
\item Programs can be very short and compact
\item Very reusable, well-structured, modular
\item Each significant piece implemented in one place
\item Functions are first-class values!
\begin{itemize}
\item Pass functions as arguments (today)
\item Return them as results (next week)
\end{itemize}
\end{itemize}
\subsubsection{Abstracting over common functionality}
\label{sec:org8bc5c88}
Want to write a recursive function that sums up over an integer range: \(\sum_{k=a}^{k=b}k\)

\begin{verbatim}
let rec sum (a,b) =
if a > b then 0 else a + sum(a+1,b)
\end{verbatim}

Now what if we want to make a sum of squares? \(\sum_{k=a}^{k=b}k^2\)

\begin{verbatim}
let rec sum (a,b) =
if a > b then 0 else square(a) + sum(a+1,b)
\end{verbatim}

\(\sum_{k=a}^{k=b}2^k\)

\begin{verbatim}
let rec sum (a,b) =
if a > b then 0 else exp(2,a) + sum(a+1,b)
\end{verbatim}

\begin{itemize}
\item So you can reimplement the function every time, but it would be more useful to make a sum function that will sum up what you tell it to (what to do to each element)
\item Non-Generic Sum (old)
\begin{itemize}
\item int * int -> int
\end{itemize}
\item Generic Sum using a function as an argument
\begin{itemize}
\item (int -> int) -> int * int -> int
\end{itemize}
\end{itemize}

\subsection{Demo}
\label{sec:org9623bc1}
\begin{verbatim}
(* Arbitrary functions *)
(* cube, rcube, square, exp, sumInts, sumSquare, sumCubes, sumExp *)
let square x = x * x;;
let cube x = x * x * x;;
let rec exp (a, b) = match a with
  | 

  (* Non-generalized sums  *)
  let rec sumInts (a,b) = if (a > b) then 0 else a + sumInts(a+1,b);;
let rec sumSquare(a,b) = if (a > b) then 0 else square(a) + sumSquare(a+1,b);;
let rec sumCubes(a,b) = if (a > b) then 0 else cube(a) + sumCubes(a+1, b);;


(* We will abstract over the function f (i.e. cube, square, exp etc) 
 to get a general sum function*)

(* sum: (int -> int) -> int * int -> int  *)
let rec sum f(a,b) =
  if a > b then 0
  else f(a) + sum f(a+1, b);;

(* Call function on a *)

(* Identity function, returns Argo *)
let id x = x;;
let exp2 x = exp (2, x);;

(* let sumInts' (a,b) = sum id (a,b);; *)
(* anonymous functions *)
let sumInts' (a,b) = sum (fun x -> x) (a,b);;

(* let sumSquare' (a,b) = sum square(a,b);; *)
let sumSquare' (a,b) = sum (fun x -> x * x) (a,b)

let sumCubes' (a,b) = sum cube(a,b);;

(* let sumExp' (a,b) = sum exp2(a,b);; *)
let sumExp' (a,b) = sum (fun x-> exp (2,x)) (a,b);;

(* Inconvenient, we have to define a function beforehand *)
(* How can we define a function on the fly without naming it?
 -> Use anonymous functions*)

(* Different ways to make anonymous functions *)
fun x y -> x + y;;
function x -> x;;
fun x -> x;;
(* Can use function for pattern matching 
 Don't need to write match
 Function can only take in one argument and implies pattern matching
 fun can take many *)
(function 0 -> 0 | n -> n+1);;
(* Equivalent to fun and match *)
(fun x -> match x with 0 -> 0 | n -> n+1);;


(* comb: is how we combine - either * or + 
 f : is what we do to the a
 inc : is how we increment a to get to b
 base : is what we return when a > b *)
(* Make this tail recursive this time  *)
let rec series comb f (a,b) inc base =
  if a > b then base
  else series comb f (inc(a),b) inc (comb base (f a));;
(* Base acts as an accumulator *)
\end{verbatim}

\begin{itemize}
\item How about only summing up odd numbers?
\end{itemize}

\begin{verbatim}
let rec sumOdd (a,b) =
if (a mod 2) = 1 then 
sum (fun x -> x) (a, b)
else 
sum (fun x -> x)(a+1, b)
\end{verbatim}


\begin{itemize}
\item Adding increment function
\end{itemize}
\begin{verbatim}
let rec sum f (a, b) inc =
if (a > b) then 0 else (f a) + sum f (inc(a), b) inc


let rec sumOdd (a,b) =
if (a mod 2) = 1 then 
sum (fun x -> x) (a, b) (fun x -> x+1)
else 
sum (fun x -> x)(a+1, b) (fun x-> x+1)
\end{verbatim}

\begin{itemize}
\item How about only multiplying?
\end{itemize}

\begin{verbatim}
let rec product f (a, b) inc =
if (a > b) then 1 else (f a) * product f (inc(a), b) inc
\end{verbatim}

\begin{itemize}
\item Can make this tail recursive with accumulators for base (1 for prod, 0 for sum)
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
\begin{itemize}
\item Types: 
\begin{itemize}
\item (int -> int -> int) : comb

\item series: -> (int -> int) : f

\item int * int : a,b lower and upper bound

\item int -> int : inc

\item int : base
\end{itemize}
\end{itemize}

Types can get crazy, too much abstraction may lead to less readability
\subsection{Bonus}
\label{sec:org84d7fb9}
Approximating the integral
\begin{itemize}
\item \(l = a + dx/2\)
\begin{itemize}
\item Use rectangles to approximate
\item Left side of l is above the rectangle, right side is below, approximation should almost cancel them
\item \(\int_a^b f(x) dx \approx f(l)*dx + f(l+dx)*dx+f(l+dx+dx)*dx+\ldots =dx * (f(l)+f(l+dx)+f(l+2*dx)+f(l+3*dx) \ldots)\)
\end{itemize}
\end{itemize}

Want: sum: \(\underbrace{(float -> float)}_f -> (\underbrace{float}_l * \underbrace{float}_u) -> \underbrace{(float -> float)}_{inc} -> float\)

\begin{verbatim}
let integral f (a,b) dx =
dx * sum f (a+.(dx/2.),b) (fun x-> x+. dx)
(* Follows format of sum function above
Can easily write a short program like above*)
\end{verbatim}
\section{Lecture 10 \textit{<2017-10-03 Tue>}}
\label{sec:orgfcbe8c0}
\begin{verbatim}
(* Common built in higher-order functions we'll be writing *)

(* map: ('a -> 'b) -> 'a list -> list, bracket does whatever function f does *)
(* map is the most important higher order function *)
let rec map f l = match l with
  | [] -> []
  (* Apply function to head and then prepend to what you get from recursive call *)
  | h :: t -> (f h) :: map f t;;

(* Increment all by one  *)
map (fun x -> x + 1) [1 ; 2 ; 3 ; 4];;

(* Convert to strings *)
map (fun x -> string_of_int x) [1 ; 2 ; 3 ; 4];;

(* filter: ('a -> bool) -> 'a list -> 'a list  
 Want to filter out elements of a list  
 function in bracket takes an argument and returns boolean whether it's good or not*)
(* Ex. filter (fun x-> x mod 2 = 0) [1 ; 2 ; 3 ; 4] should give [2 ; 4] *)
let rec filter p l = match l with
  | [] -> []
  | h :: t ->
     (* If it satisfies p, prepend to recursive call *)
     if p h then h :: filter p t 
     else filter p t;;

(* Being on the safe side, we can write: 
 * let pos l = filter (fun x -> x > 0) l *)

(* But we can also write , because it partially evaluates function
 * What we get back is a function from 'a list -> 'a list
 * and we can return a function *)
let pos = filter (fun x -> x > 0);;

pos [1 ; -1 ; 2 ; -3 ; -4 ; 7];;

(* fold_right: _f_ -> _base/init_ -> 'a list -> _result_
`* fold_right: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b 
 * Also known as reduce in some other languages
 * For example, if we want to sum over a list we'd write: *)

(* let rec sum l =
 *   let rec suma l acc = match l with
 *     | [] -> acc
 *     | h::t -> suma t (h+acc) in
 *   suma l 0;;
 * 
 * (\* sum [1 ; 2 ; 3 ; 4];; *\)
 * (\* 1+(2+(3+(4+0))) *\)
 * 
 * let rec prod l =
 *   let rec proda l acc = match l with
 *     | [] -> acc
 *     | h::t -> proda t (h*acc) in
 *   suma l 1;; *)
(* For a string, we'd concat instead of add or multiply 
 * So we want to abstract this common functionality *)

(* 1, f(2, f(3,f(4))) *)

(* fold_right f init [x1 ; .... ; xn] 
 * ==> f(x1, f(x2,... (f(xn, init))))
 * fold_right: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b *)

let rec fold_right f init l = match l with
  | [] -> init
  | h :: t -> f(h, fold_right f init t);;
(* Not really tail recursive, can make it tail recursive though *)


fold_right (fun (x,acc)->x+acc) 0 [1 ; 2 ; 3 ; 4 ; 5];; (* sum *)
fold_right (fun (x,acc)->x*acc) 1 [1 ; 2 ; 3 ; 4 ; 5];; (* prod *)

(* Concatenate as strings in list 
 * Convert each int to a string and use ^ operator to concatenate 2 strings
 * init is empty string*)
fold_right (fun (x,acc)->(string_of_int x) ^ acc) "" [1 ; 2 ; 3 ; 4 ; 5];;


(* Function that adds two numbers, but doesn't work with fold_right 
 * as it needs a function that takes a tuple, not 2 ints  *)
(+) 3 4;;

(* Folds the other way, will see difference with String function, 
 * but not with commutative things like addition
 * fold_left f init [x1 ; .... ; xn] ==> f(xn, (f (xn-1, ... (f (x1, init)))))
 * fold_left: ('a * b' -> 'b) -> 'b -> 'a list -> 'b*)

let rec fold_left f init l = match l with
  | [] -> init
  | h::t -> fold_left f (f (h, init)) t;;

fold_left (fun (x,acc)->(string_of_int x) ^ acc) "" [1 ; 2 ; 3 ; 4 ; 5];;

(* for_all p l returns true if all elements in l satisfy p *)
(* let rec for_all p l  *)

(* exists p l returns true if there exists an elements in l satisfy p *)

(* Things in basic library *)
List.map;;
List.fold_right;;
List.fold_left;;
List.filter;;
List.for_all;;
List.exists;;
(* etc *)
(* Writing these functions is good practice *)
\end{verbatim}
\section{Lecture 11 \textit{<2017-10-05 Thu>}}
\label{sec:org5a9cb5c}
\subsection{Lambda-Calculus}
\label{sec:org050d341}
\begin{itemize}
\item Simple language consisting of variables, functions (written as \(\lambda x.t\)) and function application
\item We can define all computable functions in the Lambda-Calculus
\item Church Encoding of Booleans:
\begin{itemize}
\item T = \(\lambda x.\lambda y.x\) Keeps first argument, throws the other.
\item F = \(\lambda x.\lambda y.y\) Keeps second argument, throws the other.
\item Lambda-Calculus is Turing complete, can do everything with it
\end{itemize}
\end{itemize}
\subsection{Back to the beginning}
\label{sec:orgbb4c16f}
\begin{verbatim}
(*Binding variables to functions*)
let area : float -> float = function r -> pi *. r *. r
(*or*)
let area (r:float) = pi *. r *. r
\end{verbatim}

\begin{itemize}
\item The variable name area is bound to the value function r -> pi *. r *. r, which OCaml prints as <fun>
\begin{itemize}
\item The type is float->float
\end{itemize}
\item Good question:
\begin{itemize}
\item let plus x y = x + y
\item What is the type of plus?
\begin{itemize}
\item An integer? (answer 1) Wrong
\item int -> int -> int (answer 2) \uline{Correct answer}
\item A function (answer 3) Wrong, function is not the \textbf{type}
\end{itemize}
\item let plus' (x,y) = x+y
\begin{itemize}
\item type is int * int -> int
\end{itemize}
\end{itemize}
\item What are types?
\begin{itemize}
\item Base types: Int, float, string\ldots{}
\item If T is a type and S is a type then
\begin{itemize}
\item T->S is a type
\item T*S is a type
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Curry}
\label{sec:org39c5d0a}
let curry \(\underbrace{f}_{\text{'a * 'b -> 'c}}= fun \underbrace{x}_{\text{'a}}  \underbrace{y}_{\text{'b}} \text{ -> } f \overbrace{(x, y)}^{\text{'a * b}}_{\text{'a -> 'b -> 'c}}\)
\begin{itemize}
\item curry \(\underbrace{plus'}_{\text{int * int -> int}}\): int -> int -> int
\item fun x y -> plus' (x,y)
\begin{itemize}
\item OCaml gives you <fun>
\item Shouldn't we continue evaluation plus'(x,y) and get as a final result fun x y -> x + y?
\begin{itemize}
\item No, we never evaluate inside function bodies
\item When OCaml sees fun, it stops looking
\begin{itemize}
\item It has a function, it's a value, it's done
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Uncurrying}
\label{sec:orgfae768e}
uncurry ('a -> 'b -> 'c) -> 'a * 'b -> 'c
\begin{itemize}
\item The type of functions is \uline{right associative}
\item \textbf{NOT} the same thing as 'a -> 'b -> 'c -> 'a * 'b -> 'c
\item \textbf{Important} to know how to read functions.
\begin{itemize}
\item Ex. plus function from earlier
\item Can also have plus x = fun y -> x + y
\begin{itemize}
\item int -> (int -> int)
\item Makes a function from an int
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Demo}
\label{sec:org1ff2b41}
We've already seen functions that return other functions: derivatives!
\begin{verbatim}
(* Write a function curry that takes as input 
 * a function f:('a * 'b)->c' 
 * and returns as a result a function
 * 'a->'b->'c*)

(* curry : (('a * 'b)->'c)-> 'a -> 'b -> 'c 
 * Note: Arrows are right-associative. *)
let curry f = (fun x y -> f (x,y))

let curry_version2 f x y = f (x,y)

let curry_version3 = fun f -> fun x -> fun y -> f (x,y)

						  (* Uncurry *)
						  (* uncurry ('a -> 'b -> 'c) -> 'a * 'b -> 'c *)
let uncurry f = (fun (x,y) -> f x y)

(* swap : ('a * 'b -> 'c) -> 'b * 'a -> 'c *)
let swap f = fun (b, a) -> f(a , b)                  

let plus' (x,y) = x + y

(* swap plus' ===> fun (b,a) -> plus' (a,b) *)
\end{verbatim}
\subsection{Partial evaluation}
\label{sec:orgf9c08c6}
\begin{itemize}
\item A technique for optimizing and specializing programs
\item Generate programs from other programs
\item Produce new programs which run faster than originals and guaranteed to behave in same way
\item What is the result of evaluation curry plus'?
\begin{itemize}
\item \(\implies\) It's a function!
\item Result: fun x y -> plus' x y
\begin{itemize}
\item Still waiting for x y
\item What if we just pass in 3? (plus 3)
\begin{itemize}
\item fun y -> 3 + y
\item We generated a function!
\end{itemize}
\end{itemize}
\end{itemize}
\item let plusSq x y = \(\underbrace{x * x}_{horriblyExpensiveThing(x)}\) + y
\begin{itemize}
\item fun y -> 3 * 3 + y (if we set x as 3), won't evaluate this expensive function until we give it a y
\item If we write:
\begin{itemize}
\item plusSq 3 10
\item plusSq 3 15
\item plusSq 3 20
\end{itemize}
\item We'd have to evaluate horribly expensive function 3 times.
\item Why not store it and use it for the next computation?
\end{itemize}
\end{itemize}
\#+BEGIN\_SRC ocaml
let betterPlusSq x =
	let x = horriblyExpensiveThing(x)
		in fun y -> x + y
\#+END\_SRC ocaml 
\begin{itemize}
\item Now we get:
\item let x = horriblyExpensiveThing 3 in fun y -> x+y -> fun y ->9+y
\begin{itemize}
\item Now we can use this function to quickly compute without having to do the expensive function
\item Partial evaluation is very important
\end{itemize}
\end{itemize}
\section{Lecture 12 \textit{<2017-10-06 Fri>}}
\label{sec:org1fad70e}
\begin{itemize}
\item Review by Leila: Today
\begin{itemize}
\item 6-7:30 pm, MC 103
\end{itemize}
\item Cheat sheet correction, minimum 12 pt, not max
\end{itemize}
\subsection{Review}
\label{sec:org4456d1e}
Types of questions:
\begin{enumerate}
\item fun x -> x +. 3.3
\begin{itemize}
\item What is the type?
\begin{itemize}
\item float -> float
\end{itemize}
\item What does it evaluate to?
\begin{itemize}
\item <fun> or fun x -> x +. 3.3
\end{itemize}
\item let x = 3 in x + 3
\begin{itemize}
\item type: int
\item eval: 6
\end{itemize}
\item let x = 3 in x +. 3
\begin{itemize}
\item type: error
\item eval: n/a
\end{itemize}
\end{itemize}
\item Programming in OCaml
\begin{enumerate}
\item Higher-order functions
\begin{itemize}
\item Nothing too crazy since we haven't had any assignments on it
\item Maybe like the built in functions we implemented the other day
\item using map, for$\backslash$\_all, filter, exists\ldots{}
\end{itemize}
\end{enumerate}
\item Induction proof
\end{enumerate}
\subsection{Demo, using higher order functions}
\label{sec:orgf3e7885}
\begin{verbatim}
(* simplified roulette *)
type colour = Red | Black

type result = colour option (* Result of run*)

type amt = int
type bet = amt * colour

type id = string
type player = id * amt * bet option

(* See who won *)
let compute (am, col : bet) : result -> int = function
  | None -> 0
  | Some col' -> if col = col' then am * 2 else 0

(* same as: *)

(* let compute (am, col) r = match r with
 *   | None -> 0
 *   | Some col' -> if col = col' then am * 2 else 0 *)

(* Solve all these questions without using recursion or 
 * pattern matching on lists, but instead just use the HO functions we saw in class *)

let bets = [ ("Aliya", 1000, Some (400, Red)) ;
	     ("Jerome", 800, Some (240, Black)) ;
	     ("Mo", 900, Some (200, Black)) ;
	     ("Andrea", 950, Some (100, Red))]

(* Q1: given a list of players compute the new amounts each player has and set their bets to None *)
let compute_all_results (l : player list) (r : result) =
  (* Should map players to their new vals, player has name id and amt. 
   * What function? Act on bet type
   * Keep id, add compute to amount and no more bet 
   * Need to get bet out of bet option
   * Use pattern matching*)

  (* List.map (fun (id, amt, bopt) -> match bopt with
   *                                  | None -> (id, amt, bopt)
   *                                  | Some b -> (id, amt + compute b r , None)) l *)

  (* Alternative with function *)
  List.map (function (id, amt, Some b) -> (id, amt +compute b r , None)
		   | (id, amt, None) -> (id, amt, None)) l
;;
compute_all_results bets (Some Red);;

(* Q2: given a list of bets and a result 
compute a list of winning players with their bets *)

(* Use filter *)
let compute_winners (l : player list) (r : result) =
  List.filter(function (id, amt, Some b) -> compute b r > 0
		     | (id, amt, None) -> false) l
;;
compute_winners bets (Some Red);;

(* Q3: given a list of bets and a result compute 
 * how much money the casino needs to pay back*)

(* Use fold *)

(* Q4 : given a list of bets and a result 
 * compute if nobody won *)
(* Check if there is a winner (exists ho func) or if everyone is a loser (for_all) *)
\end{verbatim}
\section{Lecture 13 \textit{<2017-10-12 Thu>}}
\label{sec:org9bde7c4}
\subsection{Midterm Review}
\label{sec:org5a07b1e}
See either 13.ml or Midterm.ml for the questions.
\section{Lecture 14 \textit{<2017-10-13 Fri>}}
\label{sec:org52d2b94}
How can we do imperative programming (like C) in a functional language?
\begin{itemize}
\item So far, expressions in OCaml have:
\begin{itemize}
\item An expression has a type
\item Expression evaluates to a value (or diverges)
\end{itemize}
\item Today:
\begin{itemize}
\item Expressions in OCaml may also have an effect (one effect is allocating values to memory and updating them)
\end{itemize}
\end{itemize}
\subsection{Overshadowing}
\label{sec:orga4cb0ef}
Recall: 
\begin{verbatim}
let (k : int) = 4;;
let (k : int) = 3 in k * k;;
k;; (* This will be 4! *)
\end{verbatim}
Binding in line 2 will be gone after line 2.
\begin{verbatim}
let pi = 3.14;;
let area (r:float) = pi *. r *. r;;

let a2 = area (2.0)

let (pi : float) = 6.0;;

let b1 = area (2.0) = a2 (* True *)

let area (r:float) = pi *. r *. r;;
let b2 = area (2.0) = a2 (* False *)
\end{verbatim}
For b1, calling area will use the old definition of pi (it already evaluated it when we created the function).
\subsection{State}
\label{sec:org17401e3}
How to program with state? We may want to update memory, for example if we have values that change or an array.
\begin{itemize}
\item How to allocate state?
\end{itemize}
\begin{verbatim}
let x = ref 0
\end{verbatim}
Allocates a reference cell with the name x in memory and initializes it with 0. Not the address, cannot do address manipulation.
\begin{itemize}
\item How to compare 2 reference cells?
\begin{itemize}
\item Compare their address: \texttt{r == s}
\begin{itemize}
\item Succeeds if both are names for the same location in memory.
\end{itemize}
\item Compare their content: \texttt{r = s}
\end{itemize}
\end{itemize}
\begin{verbatim}
let x = ref 0
let y = ref 0
x = y (*true*)
x==y (*false*)
\end{verbatim}
\begin{itemize}
\item How to read value stored in a reference cell?
\begin{itemize}
\item \texttt{!x}
\item \texttt{let \{contents = x\} = r}
\begin{itemize}
\item Pattern match on value that is stored in the reference cell with name x
\end{itemize}
\end{itemize}
\item How to update value stored?
\begin{itemize}
\item \texttt{x := 3}
\end{itemize}
\end{itemize}
\subsection{Demo}
\label{sec:org8ea2046}
\begin{verbatim}
let r = ref 0;;
let s = ref 0;;
r = s;; (* True *)
r == s;; (* False *)
r := 3;;
(* Update, but it returns a unit, uninteresting
 * Always true, what it says is it succeeded
 * As an effect, it changes the value in cell x.
 * But the _value_ of updating a cell is 
 * (). unit is type, it evaluates to ()
 * Keep this in mind*)
!r;;
let x = !r + !s;; (* 3 *)

(* The following is not valid: *)
(* r := 3.4;; *)
(* This is because r is an int ref *)

r := !s;;
!r;;

r := 2+3;; (*2+3 evaluated before stored*)
!r;;

(* What's the value of r? (_IMPORTANT_)
 * The address/location in memory 
 * So t = r will set t to the same address *)
let t = r;; (* Point to same loc in mem*)
t == r;;
t := 4 * 3;;
!t;;
!r;;

(* Polymorphic functions, will see later *)
let id = ref (fun x -> x);;
id := fun x -> x + 1;;
(* Will fix x to an int *)
(* This won't work: *)
(* id := fun x -> x +. 3.2;; *)

(* Can only do something like *)
id := fun x -> x + 2;;
(* Can also overshadow references *)
let id = ref (fun x -> x + 1);;

(* Back to the area example *)
let pi = ref 3.14;;
let area r = !pi *. r *. r;;

let a2 = area (2.0);; (*12.56*)
pi := 6.0;;
let a3 = area (2.0);; (*24.0*) 
a2 = a3;; (* false *)

(* Now we can write C like
 *   programs using references *)

(* Purely functional, 
 * changes addresses in triple *)
let rot (a,b,c) = (c,b,a);;

(* Purely rotten, 
 * changes contents in triple *)
let rott (a,b,c) = let t = !a in (a := !c ; c := t ; (a,b,c)) ;;

let triple = (ref 1, ref 2, ref 3);;
rot triple;;
rott triple;;
(* They don't both do the same thing,
 * since one changes addresses vs contents *)


(*Imperative factorial
 * More complicated than purely functional ver
 * Considered bad style in functional
 * Harder to reason about its correctness 
 * Harder to understand*)
let imperative_fact n =
  begin
    let result = ref 1 in
    let i = ref 0 in
    let rec loop () =
      if !i = n then ()
      else (i := !i + 1; result := !result * !i; loop ())
    in
    (loop (); !result)
  end
\end{verbatim}
\begin{itemize}
\item Updating a cell in memory has
\begin{itemize}
\item a value (i.e. unit, written in OCaml as \texttt{()})
\item an effect (i.e. changes the value in cell x)
\end{itemize}
\item Types
\begin{itemize}
\item \texttt{let r = ref 0}
\begin{itemize}
\item Type of r: int ref
\item ref 0 is an int ref
\item 0 is an int
\item We cannot store a float in r
\item \texttt{!r} is an int
\item For \texttt{r:=3+2} to make sense, r should be an int ref and 3+2 must be an int. This returns a type of unit.
\end{itemize}
\end{itemize}
\end{itemize}
\section{Lecture 15 \textit{<2017-10-17 Tue>}}
\label{sec:orgf4a37b1}
\subsection{Warm up}
\label{sec:orga882796}
Given the following expression write down its type, its value (i.e. what the expression evaluates to), and its effect, if it has any.
\begin{itemize}
\item Usually on exams, they should all type check. The error option is just in case they make a typo in typing the question.
\item \texttt{3+2}
\begin{itemize}
\item \texttt{int}
\item \texttt{5}
\item No effect
\end{itemize}
\item \texttt{55}
\begin{itemize}
\item \texttt{int}
\item \texttt{55}
\item No effect
\end{itemize}
\item \texttt{fun x -> x+3 *2}
\begin{itemize}
\item \texttt{int -> int}
\item \texttt{<fun>} or \texttt{fun x -> x + 3 * 2}
\end{itemize}
\item \texttt{((fun x -> match x with [] -> true | y::ys -> false), 3.2 *. 2.0)}
\begin{itemize}
\item \texttt{('a list -> bool) * float}
\item \texttt{(<fun>,6.4)}
\item No effect
\end{itemize}
\item \texttt{let x = ref 3 in x := !x + 2}
\begin{itemize}
\item Example: \texttt{let k=1 in k+2} is an int, and \texttt{k=1} gets discarded after \texttt{k+2}
\item \texttt{unit}
\item \texttt{()}
\item Effect? No, x is disposed of. Removed from the stack after evaluation in this example. x is now unbound
\end{itemize}
\item \texttt{fun x -> x := 3}
\begin{itemize}
\item \texttt{int ref -> unit}
\item \texttt{<fun>}
\item Effect: updated x to 3
\end{itemize}
\item \texttt{(fun x -> x := 3) y}
\begin{itemize}
\item type: unit
\item value: ()
\item Effect: updated y to 3
\end{itemize}
\item \texttt{fun x -> (x := 3; x)} (returns x)
\begin{itemize}
\item \texttt{int ref -> int ref}
\end{itemize}
\item \texttt{fun x -> (x := 3; !x)} (returns !x)
\begin{itemize}
\item \texttt{int ref -> int}
\end{itemize}
\item \texttt{let x = 3 in print\_string (string\_of\_int x)}
\begin{itemize}
\item type: unit
\item value: ()
\item Effect: prints 3 to the screen
\end{itemize}
\end{itemize}
\subsection{Demo}
\label{sec:org4e529fd}
\begin{verbatim}
();;
(* unit *)

fun x -> x := 3;;
let y = ref 1;;
(fun x -> x := 3) y;;
y;;
let x = ref 1 in
    fun x -> (x := 3; x);;

(* Linked list *)
type 'a rlist = Empty | RCons of 'a * ('a rlist) ref;;
let l1 = ref (RCons (4, ref Empty));;
let l2 = ref (RCons (5, l1));;
(* The 'a rlist ref of l2 is l1, same address *)

(* What happens here? *)
l1 := !l2;;
(* We have created a circular list *)
!l1;;
\end{verbatim}
\section{Lecture 16 \textit{<2017-10-19 Thu>}}
\label{sec:orgcccd622}
\subsection{Demo}
\label{sec:orgf5f19d2}
\begin{itemize}
\item Mutable Data-Structures
\item Closures and Objects
\end{itemize}
\begin{verbatim}
type 'a rlist = Empty | RCons of 'a * ('a rlist) ref

let l1 = ref (RCons (4, ref Empty))
let l2 = ref (RCons (5, l1));;

l1 := !l2;;
(* Value is (), effect is changing link to itself *)

(* Append for regular lists *)
let rec append l1 l2 = match l1 with
  | [] -> l2
  | x::xs -> x::(append xs l2)

(* Append for rlist *)
type 'a refList = ('a rlist) ref
(* Return unit, as the "result" is the effect *)
(* 'a refList->'a refList->unit *)
let rec rapp (r1 : 'a refList) (r2 : 'a refList) = match r1 with
  | {contents = Empty} -> r1 := !r2
  | {contents = RCons (x, xs)} -> rapp xs r2

(* 'a refList -> 'a refList -> 'a rlist *)
let rec rapp' (r1 : 'a refList) (r2 : 'a refList) = match r1 with
  | {contents = Empty} -> {contents = r2}
  | {contents = RCons (x, xs)} -> rapp' xs r2

let r = ref (RCons (2, ref Empty))
let r2 = ref (RCons(5, ref Empty));;


let r3 = rapp' r r2;;
r3;;
rapp r r2;;
r;;

let (tick, reset) =
  let counter = ref 0 in
  (* Input is unit, always true. Not the same as void *)
  let tick () = (counter := !counter + 1 ; !counter) in
  let reset () = counter := 0 in
  (tick, reset);;


(* Now we have 2 functions, tick and reset *)
tick ();;
tick ();;

type counter_obj = {tick : unit -> int ; reset : unit -> unit}

let makeCounter () =
  let counter = ref 0 in
  {tick = (fun () -> counter := !counter + 1 ; !counter);
   reset = (fun () -> counter := 0)};;

(* global variable *)
let global_counter = ref 0
let makeCounter' () =
  let counter = ref 0 in
  {tick = (fun () -> counter := !counter + 1 ; global_counter := !counter ; !counter);
   reset = (fun () -> counter := 0)};;

let c = makeCounter ();;
c.tick ();;
c.tick ();;
let d = makeCounter ();;
d.tick ();;
c.tick ();;
d.reset ();;
\end{verbatim}
\section{Lecture 17 \textit{<2017-10-20 Fri>}}
\label{sec:orgd7e178e}
\subsection{Exceptions}
\label{sec:orgad458ca}
\begin{itemize}
\item Primary benefits:
\begin{itemize}
\item Force you to consider the exceptional case
\item Allows you to segregate the special case from other cases in the code (avoids clutter!)
\item Diverting control flow!
\end{itemize}
\end{itemize}
\subsubsection{Warm-up}
\label{sec:org85fc95d}
\begin{itemize}
\item \texttt{3/0}
\begin{itemize}
\item Type: \texttt{int}
\item Value: No value
\item Effect: Raises run-time exception \texttt{Division\_by\_zero}
\end{itemize}
\end{itemize}
\begin{verbatim}
let head_of_empty_list =
    let head (x::t) = x in
	head []
\end{verbatim}
\begin{itemize}
\item Type: \texttt{'a}
\begin{itemize}
\item head is \texttt{'a list -> 'a}, so it returns \texttt{'a} in last line
\item Value: No value
\item Effect: raises run-time exception \texttt{Match\_failure}
\item Would have been well-defined if we used option return type
\end{itemize}
\end{itemize}
\subsubsection{Demo}
\label{sec:orgc115613}
\begin{enumerate}
\item Signal Error
\begin{itemize}
\item Ex. raise Domain
\end{itemize}
\item Handle an exception
\begin{itemize}
\item Try <exp> with Domain -> <exp>
\end{itemize}
\end{enumerate}
\begin{verbatim}
exception Domain

let fact n =
  let rec f n =
    if n = 0 then 1
    else n * f (n-1)
  in
  if n < 0 then raise Domain
  else f(n)

let runFact n =
  try
    let r = fact n in
    print_string ("Factorial of "^ string_of_int n ^
		    " is " ^ string_of_int r ^ "\n")
  with Domain ->
    print_string("Error: Trying to call factorial on a negative input \n");;

fact 0;;
fact (-1);;

(* let fact' n =
 *   let rec f n =
 *     if n = 0 then 1
 *     else n * f (n-1)
 *   in
 *   if n < 0 then raise (Error "Invalid Input")
 *   else f(n)
 * 
 * let runFact' n =
 *   try
 *     let r = fact n in
 *     print_string ("Factorial of "^ string_of_int n ^
 *                     " is " ^ string_of_int r ^ "\n")
 *                  (\* with Error msg ->
 *                   *   print_string(msg ^ "\n");; *\)
 *                  (\* Can pattern match here too *\)
 *   with Error "Invalid Input" -> print_string ("Programmer says you passed an invalid input \n")
 *      | Error msg -> print_string(msg ^ "\n") *)

type key = int

type 'a btree =
  | Empty
  | Node of 'a btree * (key * 'a) * 'a btree



(* let l = Node (Node (Empty, (3, "3"), Empty), (7,"7"),
 *               Node (Empty, (4, "4")  *)

(* Binary search tree searching *)
exception NotFound
(* Can use exceptions for positive things as well *)
exception Found of int


(* let rec findOpt1 t k = match with
 *   | Empty -> raise NotFound
 *   | Node(l, (k',d),r) ->
 *      if k = k' then raise (Found d)
 *      else
 *        (if k < k' then findOpt1 l k else findOpt1 r k) *)

(* Now we don't assume that the tree is a binary search tree *)
let rec findOpt t k = match t with
  | Empty -> None
  | Node(l, (k',d), r) ->
     if k = k' then Some d
     else
       (match findOpt l k with
	| None-> findOpt r k
	| Some d -> Some d)

(* Doing it with exceptions *)

let rec find t k = match t with
  | Empty -> raise Not_Found
  | Node (l, (k', d), r) ->
     if k = k' then d
     else try (find l k with NotFound -> find r k) 
\end{verbatim}
\section{Lecture 18 \textit{<2017-10-24 Tue>}}
\label{sec:orgbf4b1ce}
\subsection{Backtracking}
\label{sec:org351f19e}
\begin{itemize}
\item General algorithm for finding all (or some) solutions incrementally - abandons partial candidates as soon as it determines that it cannot lead to a successful solution
\item Important tool to solve constraint satisfaction problems such as crosswords, puzzles, Sudoku, etc.
\item Ex today:
\begin{itemize}
\item Implement a function \texttt{change}. It takes as input a list of available coins and an amount \texttt{amt}. It returns the exact change for the amount (i.e. a list of available coins, \texttt{[c1;c2;...;cn]} such that \texttt{c1 + c2 + ... + cn = amt}), if possible; otherwise it raises an exception \texttt{Change}.
\end{itemize}
\end{itemize}
\texttt{change : int list} (list of coins) \texttt{-> int} (amt) \texttt{-> int list} (list of coins)
\begin{itemize}
\item Assumptions:
\begin{itemize}
\item List of coins is ordered
\item Each coin in our list can be used as often as needed
\end{itemize}
\item Good practice/exam question
\end{itemize}
\begin{verbatim}
let listToString l = match l with
  | [] -> ""
  | l ->
     let rec toString l = match l with
       | [h] -> string_of_int h
       | h::t -> string_of_int h ^ ", " ^ toString t
     in
     toString l

	      (*        change [50;25;10;5;2;1] 43;;
	       * [25; 10; 5; 2; 1]
	       *   change [50;25;10;5;2;1] 13;;
 * [10;2;1]
 *   change [5;2;1] 13;;
 * [5;5;2;1] *)

exception Change

let rec change coins amt =
  if amt = 0 then []
  else
    (
      match coins with
      | [] -> raise Change
      (* Cannot print here, as it won't do any backtracking and 
       * will also give you a type error since it's a unit and we're trying to build a list *)
      (* raise Change is any type  *)
      | coin :: cs -> if coin > amt then change cs amt
		      else (* coin <= amt*)
			(* Prepend coin as we're trying to use this coin for result *)
			try coin::(change coins (amt - coin) )
				    (* Try, if you fail, try again without given coins*)
			with Change -> change cs amt
    )
\end{verbatim}

Backtracking with exceptions:
\begin{itemize}
\item Given \texttt{change[6,5,2] 9}
\item \texttt{try 6::change[6;5;2] 3 with Change -> change [5;2] 9}
\begin{itemize}
\item \texttt{change [5;2] 3}
\begin{itemize}
\item \texttt{change[2] 3}
\item \texttt{try 2::change[2] 1} will not work, raise Change and get back to \texttt{change [5;2] 9} from before
\end{itemize}
\end{itemize}
\end{itemize}
Key thing to take away is:
\begin{itemize}
\item You can use exceptions for special cases like dividing by 0
\item But a more interesting use is that you can divert control flow
\item So you can use it to backtrack and solve problems
\end{itemize}
\section{Lecture 19 \textit{<2017-10-26 Thu>}}
\label{sec:orgeb2bfc5}
\subsection{Modules}
\label{sec:orgb0c28c2}
Primary Benefits:
\begin{itemize}
\item Control complexity of developing and maintaining software
\item Split large programs into separate pieces
\item Name space separation
\item Allows for separate compilation
\begin{itemize}
\item Don't always want to recompile the whole project after a small change
\item Incremental compilation \& type checking
\end{itemize}
\item Incremental development
\item Clear specifications at module boundaries
\item Programs are easier to maintain and reuse (!)
\item Enforces abstractions
\item Isolates bugs
\end{itemize}
\subsection{Signatures (Module Types)}
\label{sec:orga4a528e}
\begin{itemize}
\item Declarations can be more specific in the signature than what the module actually implements
\item Tying a module to a module type we are hiding information!
\begin{itemize}
\item We can change the module implementation in the future and users won't notice as long as it still implements what we specified in the signature
\end{itemize}
\item Order of signature doesn't have to have the same order as module
\end{itemize}
\subsection{Demo}
\label{sec:org0314b99}
\begin{verbatim}
(* Want to give an interface to this module 
 * What functions do we want to expose? 
 * Called signature in OCaml*)
module type STACK =
  sig
    type stack
    type el
    val empty : unit -> stack
    val is_empty : stack -> bool
    val pop : stack -> stack option
    val push : el -> stack -> stack
(* val push : int -> stack -> stack *)
  (* If we change this to el -> stack -> stack 
 * Stack.push 1 s wouldn't work, because 1 isn't a Stack.el*)
  end

(* 1 program unit with namespace separation *)
(* If you want to access the module need to write Stack.function *)

(* module Stack = *)

(* Specify that Stack implements STACK *)
(* module Stack : STACK = *)

(* Specify what type el is *)
module Stack : (STACK with type el = int) =
  struct
    type el = int
    type stack = int list

    let empty () : stack = []

    let push i (s : stack) = i::s

    let is_empty s = match s with
      | [] -> true
      | _::_ -> false

    let pop s = match s with
      | [] -> None
      | _::t -> Some t

    let top s = match s with
      | [] -> None
      | h::_ -> Some h

    let rec length s acc = match s with
      | [] -> acc
      | x::t -> length t 1+acc

    let size s = length s 0

    let stack2list(s:stack) = s
  end

let s = Stack.empty();;
(* empty;; -> unbound, packaged in module *)
let s1 = Stack.push 1 s;;
(* Will not show you that the stack is a list 
 * Didn't specify in the signature *)
(* Cannot do: 1 :: s1;; *)
(* By tying module to signature, you are hiding information *)

module FloatStack : (STACK with type el = float) =
  struct
    type el = float
    type stack = float list

    let empty () : stack = []

    let push i (s : stack) = i::s

    let is_empty s = match s with
      | [] -> true
      | _::_ -> false

    let pop s = match s with
      | [] -> None
      | _::t -> Some t

    let top s = match s with
      | [] -> None
      | h::_ -> Some h

    let rec length s acc = match s with
      | [] -> acc
      | x::t -> length t 1+acc

    let size s = length s 0

    let stack2list(s:stack) = s
  end

module IS = Stack
module FS = FloatStack

(* How do we test the length function without a module specifying it? 
 * DANGEROUS
 * Use open*)
(* open Stack;; 
 * Now erases all namespace boundaries
 * Don't need to prefix anymore *)
\end{verbatim}
\section{Lecture 20 \textit{<2017-10-27 Fri>}}
\label{sec:org226896a}
\subsection{More on Modules}
\label{sec:org75bc0c0}
\begin{itemize}
\item Can hide information when we bind to a module type
\item Don't expose how we implement it
\item Can even hide what elements we store in the stack
\item Nice level of abstraction, so we can easily rip out the implementation and put in a new one
\item Makes programs easy to maintain
\item Modules are great for enforcing abstraction
\end{itemize}
\subsection{Demo}
\label{sec:org1e86dd5}
\begin{itemize}
\item Want to implement different currencies
\item Bank
\item Money
\end{itemize}
\begin{verbatim}
module type CURRENCY =
  sig
    type t
    val unit : t
    val plus : t -> t -> t
    val prod : float -> t -> t
    val toString : t -> string
  end;;

(* Here, float is not yet tied to currency *)
(* Ideally, we'd also like to define multiple currencies *)
module Float =
  struct
    type t = float
    let unit = 1.0
    let plus = (+.)
    let prod = ( *. )
    let toString x = string_of_float x
  end;;

(* Abbreviation for a module *)
(* module Euro = Float *)
(* But we don't just want to abbreviate it, 
 * want to also say it implements currency *)
module Euro = (Float : CURRENCY);;
module USD = (Float : CURRENCY);;
module CAD = (Float : CURRENCY);;
module BitCoins = (Float : CURRENCY);;
(* All these currencies use the same implementation of float, 
 * but all referring to different implementations 
 * Important that we specify CURRENCY here rather than in float
 * so that they can be different
 * Want to keep abstraction. We made plus and prod require Euros
 * so we don't just add floats*)
(* Isomorphic structures, but all accessed differently *)

(* Conversion functions  *)
let euro x = Euro.prod x Euro.unit
let usd x = USD.prod x USD.unit
let cad x = CAD.prod x CAD.unit
let bitcoins x = BitCoins.prod x BitCoins.unit

let x = Euro.plus (euro 10.0) (euro 20.5);;
(* Will not show result because it is abstract 
 * Can show result by printing/showing with toString*)

Euro.toString x;;

(* Euro.plus (euro 10.0) (10.0) does not work *)

Euro.plus;;
(* Euro.t -> Euro.t -> Euro.t 
 * Requires Euros *)

(* If we say that Float : CURRENCY when declaring module 
 * will still get different types for 
 * module Euro = Float;; module USD = Float;;
 * Just aliases for different types
 * Not actually different!
 * Binding to signature multiple times makes them all different
 * Isomorphic, can do the same stuff, but not the same type
 * But then you'll be able to add USDs and EUROs*)

(* Important principle since you're abstracting 
 * implementations but also not mixing currencies *)

(* Now let's think of banks and their view 
   and how we'll implement it for them *)
module type CLIENT = (* Client's view*)
  sig
    type t (* account *)
    type currency
    val deposit : t -> currency -> currency
    val retrieve : t -> currency -> currency
    val print_balance: t -> string
  end;;

module type BANK =
  sig
    include CLIENT (* Inheritance *)
(* Don't have to literally copy all things from the client module 
 * Now has the same things as client*)

    val create : unit -> t

  end;;

(* We want banks of different currencies 
 * with particular functions, adding 2 currencies
 * printing currencies, etc.*)

(* Parameterize a module Old_Bank with the functionality 
   provided by the module type CURRENCY *)
(* Should not matter what type of currency, 
   bank should be able to do the same thing regardless of currency *)

(* Module parametized by another module is also called a functor 
 * Similar to higher order functions but for modules *)
module Old_Bank (M : CURRENCY) : (BANK with type currency = M.t) =
  (* M describes a module, can implement a module 
     with a module for currency, M *)
  struct
    type currency = M.t
    type t = { mutable balance : currency }
    (* Could have made it a currency ref *)

    let zero = M.prod 0.0 M.unit
    and neg = M.prod (-1.0)

    let create() = { balance = zero }

    let deposit c x =
      if x > zero then
	c.balance <- M.plus c.balance x; c.balance

    let retrieve c x =
      if c.balance > x then
	deposit c (neg x)
      else
	c.balance

    let print_balance c =
      M.toString c.balance
  end;;

(* How do we get an implementation of a bank now? *)

module Post = Old_Bank (Euro);;
(* How to make the client see less? *)
module Post_Client : (CLIENT with type currency = Post.currency and type t = Post.t) = Post;;
(* Tells you what is shared with Post *)

let my_account = Post.create () ;;
Post.deposit my_account (euro 100.0);;
Post_Client.deposit my_account (euro 10.00);;
Post.print_balance my_account;;
Post_Client.print_balance my_account;;
(* Shared functionality among the two, but different ways of accessing *)

module Citybank = Old_Bank (USD);;
module Citybank_Client : (CLIENT with type currency = Citybank.currency and type t = Citybank.t) = Citybank;;

let my_cb_account = Citybank.create ();;
Citybank.deposit my_cb_account (usd 50.00);;
(* Citybank_Client.deposit my_account;; Won't work *)
\end{verbatim}
\section{Lecture 21 \textit{<2017-10-31 Tue>}}
\label{sec:orgaa68a3d}
\subsection{Continuations}
\label{sec:org1cfd2e1}
A \textbf{continuation} is a representation of the execution state of a program (for example a call stack) at a certain point in time.

Save the current state of execution into some object and restore the state from this object at a later point in time resuming its execution.
\subsubsection{First-class Support for Continuations}
\label{sec:orgdbe0408}
\begin{center}
\begin{tabular}{ll}
C\# & async/wait\\
Racket & call-with-current-continuation\\
Ruby & callcc\\
Scala & shift/reset\\
Scheme & callcc\\
\end{tabular}
\end{center}

Ocaml doesn't have first-class support, so we'll be using functions as continuations! Back to higher order functions.
\begin{itemize}
\item Back to the beginning: Recall what tail-recursive means. Can every recursive function be written tail-recursively?
\end{itemize}
\begin{verbatim}
let rec append l k = match l with
  | [] -> k
  | h::t -> h::append t k
\end{verbatim}
\begin{itemize}
\item Not tail-recursive, because of \texttt{h::append t k}
\item But still efficient
\item Can we rewrite it tail-recursively?
\end{itemize}
\subsubsection{Recipe}
\label{sec:orgd824ad0}
How to re-write a function tail-recursively?
\begin{itemize}
\item Add an additional argument, a \textbf{continuation}, which acts like an accumulator
\item In the base case, we call the continuation
\item In the recursive case, we build up the computation that still needs to be done.
\end{itemize}
A continuation is a stack of functions modeling the call stack, i.e. the work we still need to do upon returning.
\begin{itemize}
\item Not always easy to do this, the earlier attempt at tail recursion for append reversed the list.
\end{itemize}
\subsubsection{Demo}
\label{sec:org065e178}
\begin{verbatim}
(* append: 'a list -> 'a list -> 'a list *)
let rec append l k = match l with
  | [] -> k
  | h::t -> h::(append t k)

(* Tail recursive *)
(* app_tl: 'a list -> 'a list -> ('a list -> 'a list) -> 'a list *)
(* First 'a list in c is "waiting for result" of rec call 
   and last one is final result *)
let rec app_tl l k c = match l with
(* | [] -> ?
 * | h::t -> app_tl t k ? *)
(* How to do this? Need something with a hole, i.e. a function *)
  (* When you do app [1;2] [3;4] ([3;4 = k]) -> 1::app [2] [3;4] 
   * -> 1::2::app [] [3;4] What to give to c here? [3;4]*)
  (* c = (fun r -> 1::2::r) *)
  (* Parameterized function, can call and start using *)
  (* c k -> 1::2::[3,4] *)
  | [] -> c k (* Calling the continuation 
	       - passing to the call stack k*)
  (* What to put here? *)
  (* | h::t -> app_tl t k (fun r -> h :: c r) *)
  (* This gives reverse order *)

  (* Building up the call stack: *)
  (* app_tr [1;2] [3;4] (fun r -> r) (initial continuation), ident 
   -> app_tr [2] [3;4] (fun r1 -> (fun r->r) (1::r1))
   -> app_tr [] [3;4] (fun r2-> (fun r1 -> (fun r->r) (1::r1))) (2::r2)
   Collapsing the call stack
   -> (fun r2 -> (fun r1 -> (fun r -> r) (1::r1)) (2::r2)) [3,4]
   -> (fun r1 -> (fun r-> r) (1::r1)) [2;3;4] 
   -> (fun r->r) [1;2;3;4] -> [1;2;3;4] *)
  | h::t -> app_tl t k (fun r -> c (h::r))

let rec genList n acc =
  if n > 0 then genList (n-1) (n::acc) else acc;;

let l1 = genList 8000000 [];;
let l2 = genList 4000000 [];;

(* append l1 l2 gives stack overflow*)
(* So does l1 @ l2 
 * Ocaml didn't implement it through tail-recursion
 * For short lists, it works faster
 * But it cannot append huge lists like this one
 * Program can crash vs program being a bit slower*)
app_tl l1 l2 (fun r -> r);;

let rec map l f = match l with
  | [] -> []
  | h::t -> (f h)::map t f

(* Past interview question, wanted to reimplement map tail recursively *)

let map' l f =
  let rec map_tl l f c = match l with
    | [] -> c []
    (* Build up calling stack *)
    | h::t -> map_tl t f (fun r -> c ((f h):: r))
  in
  map_tl l f (fun r -> r)
\end{verbatim}
\section{Lecture 22 \textit{<2017-11-02 Thu>}}
\label{sec:org3f28605}
\subsection{Continuation recap}
\label{sec:org5d7d11b}
\begin{itemize}
\item Building up the stack
\item Once you hit base, it collapses
\item Seen an example, tail-recursion: the continuation is a functional accumulator; it represents the call stack built when recursively calling a function and builds the final result
\item Failure Continuation: the continuation keeps track of what to do upon failure and defers control to the continuation
\item Success Continuation: the continuation keeps track of what to do upon success, defers control to the continuation, and builds the final result
\end{itemize}
\subsubsection{Demo}
\label{sec:org11825ba}
\begin{verbatim}
type 'a tree =
  | Empty
  | Node of 'a tree * 'a * 'a tree

let leaf n = Node (Empty, n, Empty)

let r = Node (leaf 22, 35, leaf 70)
let ll = Node (leaf 3, 5, leaf 7)
let l = Node(ll, 9, leaf 15)
let t = Node (l, 17, r)

(* Contrasting three different versions *)
(* Using options *)
(* find: ('a -> bool) -> 'a tree -> 'a option *)
(* Good exercise to understand a function, write types *)
let rec find p t = match t with
  | Empty -> None
  | Node (l, d, r) ->
     if (p d) then Some d
     else (match find p l with
	   | None -> find p r
	   | Some d' -> Some d')
(* Kind of messy and overcomplicated 
 * Building up a call stack that's useless
 * Have to go down all of l and then only
 * r when we're done with l*)


(* Using exceptions *)
exception Fail

let rec find_ex p t = match t with
  | Empty -> raise Fail
  | Node(l,d,r) -> if (p d) then Some d
		   else (try find_ex p l with Fail -> find_ex p r)
(* If you fail, backtrack on right tree *)
let find' p t =
  (try find_ex p t with Fail -> None)


(* Using failure continuation *)
(* Continuation: Base case, want to call call stack *)
(* In this case it's c *)
(* find_cont ('a -> bool) -> 'a tree -> (unit -> 'a option) -> 'a option *)
let rec find_cont p t c = match t with
  | Empty -> c ()
  (* Instead of raising and causing an effect here, we call continuation stack *)
  | Node(l,d,r) -> if (p d) then Some d
		   else find_cont p l (fun () -> find_cont p r)
(* If left fails, then we go on left side 
 * Building up call stack*)

let rec find'' p t = find_cont p t (fun () -> None)
			       (* If we're at the very last leaf, 
   will pass unit to call stack and will get None 
 * Could have also made a fail exception*)


find'' (fun x -> x = 22) t;;
(* find_cont p t (fun (0 -> None))
 * -> find_cont p t (fun () -> None) 
 * If this fails
 * -> find_cont p l (fun () -> find_cont p r (fun () -> None))
 * Building up stack in case going down left fails
 * Passing it up and getting ready for next time like with exceptions
 * -> find_cont p ll (fun () -> find) cont p lr ....
 * This consists of building up the call stack, remember what to do upon fail*)

(* Good reason to use this is to make it tail-recursive and not get out of memory problems *)

(* Finding all elements satisfying a given property *)
(* Recursive *)
(* findAll: ('a -> bool) -> 'a tree -> 'a list *)
let rec findAll p t = match t with
  | Empty -> []
  | Node (l, d, r) ->
     let el = findAll p l in
     let er = findAll p r in
     if (p d) then el @ (d :: er)
     else el @ er;;

findAll (fun x -> x mod 3 = 0) t;;

(* Continuations, but this time on success to build up result *)
let rec findAll' p t sc = match t with
  | Empty -> sc []
  | Node(l, d, r) ->
     if (p d) then
       findAll' p l (fun el -> findAll' p r (fun er -> sc (el @ (d::er))))
     else
       findAll' p l (fun el -> findAll' p r (fun er -> sc (el @ er)))
		(* Figure this out yourself *)
\end{verbatim}
\section{Lecture 23 \textit{<2017-11-03 Fri>}}
\label{sec:org405a39d}
\subsection{Regular expressions}
\label{sec:orgb1eddef}
Going to implement regex with continuations. This is another example of a success continuation.

You might have used them in a Unix shell:
\begin{itemize}
\item \texttt{ls *.ml}, list files with suffix ml
\item \texttt{ls hw[1-3].ml}, lists hw1.ml, hw2.ml, hw3.ml
\end{itemize}
Patterns for regular expressions:
\begin{itemize}
\item Singleton: Matching a specific character
\item Alternation: choice between two patterns
\item Concatenation: Succession of patterns
\item Iteration: indefinite repetition of patterns
\end{itemize}
More rigorously: Regular expression \(r ::= a | r_1+r_2 | r_1 r_2 | r^* | 0 | 1\)
\begin{itemize}
\item Backus-Naur-Form
\item This is an inductive definition
\item How to read this?
\item A regex is either: 
\begin{itemize}
\item \(a\), a character (anything of type char)
\item \(r_1\ r_2\) is concatenation, have both regular expressions
\item \(r_1 + r_2\) alternation, can have either
\item \(r^*\) iteration, indefinite amount
\item \(0\) None
\item \(1\) Success
\end{itemize}
\end{itemize}
Question: When does a string \(s\) match a regular expression \(r\)?
\begin{itemize}
\item If \(s\) is in the set of terms described by \(r\). (When does this happen?)
\end{itemize}
\subsubsection{Examples:}
\label{sec:org82e2158}
\begin{itemize}
\item \(a(p^*)l(e+y)\) would match \emph{apple} or \emph{apply} or \emph{ale}
\item \(g(1+r)(e+a)y\), either you succeed (skip it) or find r, \emph{grey},/gray/,/gay/
\item \(g(1+o)^*(gle)\), \emph{google},/gogle/,/goooogle/,/ggle/ (1+o) doesn't matter here, could just be o
\item \(b(ob0+oba)\), \emph{boba} but not bob
\end{itemize}
\subsubsection{Demo}
\label{sec:org5d964c9}
\begin{verbatim}
(* BNF notation *)
type regexp =
  Char of char | Times of regexp * regexp | One | Zero |
  Plus of regexp * regexp | Star of regexp

(* How to write? *)
(* String s: 
 * Never matches 0
 * Matches 1 if s = empty 
 * Matches a iff s = a
 * Matches r1+r2 iff s matches r1 or r2
 * Matches r1 r2 iff s1 = s1 s2 
   with s1 matching r1 and s2 matching r2
 * Matches r* iff s= empty or s = s1 s2 
   with s1 matching r1 and s2 matches r* *)

(* acc: regexp -> char list (each char that makes up string) 
   -> (char list -> bool) (success continuation) -> bool *)
(* Accumulating things on call stack, 
   return type of success continuation must be 
   the same as return type of acc, i.e. bool *)
(* acc (Times(r1,r2)) s *)
(* Idea: check if a prefix of s matches r1 *)
(* But we still need to check the remaining part of s with r2 
 * So we pass the whole char list to k *)
(* We use continuations as backtracking, so we don't have to 
   worry about where we split the string *)
let rec acc r clist k = match r, clist with
  | Char c, [] -> false (* Expected some characters, got nothing *)
  | Char c, c1::s -> (c = c1) && k s (* At the bottom of the stack
					If we succeed, pass rest of string to                                      call stack*)
  | Times (r1, r2), s -> acc r1 s (fun s2 -> acc r2 s2 k)
  (* Can we match remaining string as well? 
Pass to continuation and also call k, whatever it still has to do*)
  | One, s -> k s (* Nothing to do, call continuation with whole string *)
  | Plus (r1, r2), s -> acc r1 s k || acc r2 s k (*Only has to be 1*)
  | Zero, s -> false
  | Star r, s ->
     (k s) || acc r s (fun s2 -> not (s = s2) && acc (Star r) s2 k)
(* Make sure we're consuming something, s2 is smaller *)
(* Note that (ap* )(l (e+g)) is represented as: 
 * Times(Times(Char "a", Star(Char "p")),Times(Char "l",Plus(Char "e", Char "y")))*)

let string_explode s =
  tabulate (fun n -> String.get s n) ((String.length s) - 1)

let string_implode l =
  List.fold_right (fun c s -> Char.escape c ^ s) l ""

		  (* let accept r s =
		   *   acc r string_explode s  *)
\end{verbatim}
\section{Lecture 24 \textit{<2017-11-07 Tue>}}
\label{sec:org8568676}
\subsection{Lazy Programming}
\label{sec:org598fdea}
\subsubsection{Eager vs Lazy}
\label{sec:org163915d}
\begin{itemize}
\item Eager Evaluation
\begin{itemize}
\item Evaluate expressions by call-by-value
\item Variables are bound to values
\item Ex. \texttt{let x = 3+2 in x * 2}
\begin{enumerate}
\item Evaluate expression \texttt{3+2} to the value \texttt{5}
\item Evaluate expression \texttt{x*2} in an environment where variable \texttt{x} is bound to the value \texttt{5} to the final value \texttt{10}
\end{enumerate}
\item Ex. let x = horribleComp (345) in 5
\begin{enumerate}
\item Evaluate expression horribleComp (345) to some value \texttt{777}
\item Evaluate expression \texttt{5} in an environment where variable \texttt{x} is bound to the value \texttt{777} to the final value \texttt{5}. Here we bind an expression we don't need.
\end{enumerate}
\end{itemize}
\item Lazy Computation
\begin{itemize}
\item Ex. \texttt{let x = horribleComp (345) in 5}
\item Bind variables to unevaluated expressions (not values!)
\item Suspend computation \texttt{horribleComp (345)} until needed
\item Memoize results because:
\begin{itemize}
\item \texttt{let x = horribleComp (345) in x + x} will recompute horribleComp twice
\end{itemize}
\item Lazy usually doesn't go well with state, which is why most imperative languages are eager
\item Harder to reason about but very useful for:
\begin{itemize}
\item Infinite data (ex. representing all prime numbers, reading part of a file instead of the whole thing)
\item Interactive data (ex. sequence or stream of inputs)
\end{itemize}
\end{itemize}
\end{itemize}
\subsubsection{Finite vs Infinite}
\label{sec:orgfc9b9d8}
\begin{itemize}
\item Finite Data
\begin{itemize}
\item \texttt{type 'a list = Nil | Cons of 'a * 'a list}
\begin{itemize}
\item Encodes an inductive definition of finite lists
\item \texttt{Nil} is a list of type \texttt{'a list}
\item If \texttt{x} is of type \texttt{'a} and \texttt{xs} is a list of type \texttt{'a list} then \texttt{cons(x,xs)} is a list of type \texttt{'a list}
\item Nothing else is a list
\end{itemize}
\item How do we take apart lists? By pattern matching.
\item How do we reason with lists? By induction on the structure of lists
\end{itemize}
\item Infinite Data
\begin{itemize}
\item Instead of saying how to construct infinite data, we define it by the observations we make about them
\item Given a stream \texttt{1,2,3,4,5,...} we can ask:
\begin{itemize}
\item The head of the stream: \texttt{1}
\item The tail of the stream: \texttt{2, 3, 4, 5, ...}
\end{itemize}
\item Can we always make an observation? Does this terminate eventually? No, does not terminate.
\begin{itemize}
\item Observations should be productive, shouldn't go into infinite loops. We can make an observation at each step.
\end{itemize}
\end{itemize}
\end{itemize}
\subsubsection{Suspending}
\label{sec:orgfc754a0}
How to suspend and prevent evaluation of an expression?
\begin{verbatim}
  type 'a susp = Susp of unit -> 'a

  (* Force evaluation of suspended computation *)
  let force (Susp f) = f ()

(* Example of suspending and forcing computation *)
let x = Susp (fun () -> horribleComp(345)) in force x + force x
\end{verbatim}
Wrap your function in lazy programming so that it suspends computation
\begin{itemize}
\item Infinite Streams: \texttt{type 'a str = \{hd : 'a ; tl : ('a str) susp\}}
\begin{itemize}
\item Encodes a coinductive definition of infinite streams using the two observations \texttt{hd} and \texttt{tl}
\begin{itemize}
\item Asking for the head using the observation \texttt{hd} returns element of type \texttt{'a}
\item Asking for the tail using the observation \texttt{tl} returns a suspended stream of type \texttt{('a str) susp}
\item If you want more elements you need to ask for more
\item Very demand driven
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{DEMO}
\label{sec:orgbf3a6c5}
\begin{verbatim}
type 'a susp = Susp of (unit -> 'a)
(* Delay computation *)

(* Force computation *)
let force (Susp f) = f ()

type 'a str =
  {hd : 'a ; tl : ('a str) susp}

    (* Stream of 1, 1, 1, 1, 1 .... *)
    (* ones : int str *)

let rec ones =
  {hd = 1 ;
   tl = Susp (fun () -> ones) (* Suspend comp to generate more ones *)
  }

(* numsFrom n  generates stream n, n+1, n+2, ... *)
let rec numsFrom n =
  {hd = n ;
   tl = Susp (fun () -> numsFrom (n+1))} (* Ocaml stops evaluating at function *)

let nats = numsFrom 0

(* series starting with n and i-th element is k^i *)
let rec pow_seq n k =
  {hd = n ;
   tl = Susp (fun () -> pow_seq (n*k) (k))}

(* add: int str -> int str -> int str *)
let rec add s1 s2 =
  {hd = s1.hd + s2.hd;
   (* tl = Susp (fun() -> add s1.tl s2.tl)  -> this gives you an error, need to force for elm *)
   tl = Susp (fun() -> add (force s1.tl) (force s2.tl))
  }

(* smap: ('a -> 'b) -> 'a str -> 'b str *)
let rec smap f s =
  {hd = f (s.hd) ;
   tl = Susp (fun () -> smap f (force s.tl))
  }
(* take: int -> 'a str -> 'a list *)
(* peels off n elements from stream *)
let rec take n s = if n = 0 then []
		   else s.hd :: take (n-1) (force s.tl);;

take 10 ones;;
take 10 (numsFrom 1);;
take 10 (pow_seq 1 2);;
take 10 (add nats ones);;
take 10 (add nats nats);;
take 10 (smap (fun x -> x*2) nats);;
\end{verbatim}
\section{Lecture 25 \textit{<2017-11-09 Thu>}}
\label{sec:org17201cc}
\subsection{Demo}
\label{sec:org69919ce}
\begin{verbatim}
(* Continuation of last class *)
#use "24.ml";;

(* Generate: 1, 1/2, 1/4, 1/8, 1/16 *)
(* geom_series: float -> float str *)
let rec geom_series x =
  {hd = (1.0 /. x) ;
   tl = Susp (fun () -> geom_series (x *. 2.0))
  };;

take 10 (geom_series 1.0);;

(* zip: ('a * 'b -> 'c) -> 'a str -> 'b str -> 'c str *)
let rec zip f s1 s2 =
  {hd = f (s1.hd,s2.hd) ; 
   tl = Susp (fun () -> zip f (force s1.tl) (force s2.tl))
  }

(* sfilter: ('a -> bool) -> 'a str -> 'a str *)
let rec sfilter f s =
  let h,t = find_hd f s in
  {hd = h ;
   tl = Susp (fun () -> sfilter f (force t))
  }

(* find_hd: ('a bool) -> 'a str -> 'a * ('a str) susp *)
(* Use to find first element in stream satisfying f, return with tail     *)
and find_hd f s =
  if (f s.hd) then (s.hd, s.tl) else find_hd f (force s.tl);;

(* All even numbers *)
take 10 (sfilter (fun x -> x mod 2 = 0) nats);;

(* Will filter always be productive? No. It may never be true in a stream 
 * Your responsibility now *)

(* Sieve of Eratosthenes for prime numbers *)
(* Start with natural numbers from 2 *)
(* Take head and filter out all elements divisible by head *)
(* Repeat *)
let rec sieve s =
  {hd = s.hd ;
   tl = Susp(fun() -> sfilter (fun x -> not (x mod s.hd = 0)) (sieve (force s.tl)))
  }
let nats2 = numsFrom 2
let primes = sieve nats2;;

take 10 primes;;
(* take 1000 primes;; *)

(* fib(n+1)=fib(n)+fib(n-1) *)
(* fibs 0 1 1 2 3 5 *)
(* Make a copy of this but shifted *)
(* Add both entries to get next fib number *)
(* Essentially adding two streams *)
let rec fibs =
  {hd = 0 ;
   tl = Susp (fun () -> fibs')
  }
and fibs' =
  {hd = 1 ;
   tl = Susp (fun () -> add fibs fibs')};;

take 10 fibs;;
\end{verbatim}
\subsubsection{Sieve of Eratosthenes:}
\label{sec:orgbc04ad2}
Generate a stream of prime numbers
\begin{itemize}
\item Start with natural numbers starting at 2
\item \(2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \ldots\)
\item First number, \(2\) is a hit.
\item Now look at tail and filter out all even numbers.
\begin{itemize}
\item Now you have a stream of odd numbers.
\end{itemize}
\item Head this time is \(3\). Now remove all things that are multiples of \(3\)
\end{itemize}
\section{Lecture 26 \textit{<2017-11-10 Fri>}}
\label{sec:orgfd2fc29}
\subsection{Fundamental Principles in Programming Language Design}
\label{sec:orgceb63f0}
Three key questions:
\begin{itemize}
\item What are the syntactically legal expression? What expressions does the parser accept?
\begin{itemize}
\item Grammar
\end{itemize}
\item What are well-typed expressions? What expressions does the type-checker accept?
\begin{itemize}
\item Static semantics
\end{itemize}
\item How is an expression executed?
\begin{itemize}
\item Dynamic semantics
\item Why isn't a program working? Seems logically correct, but then how do we delve further?
\end{itemize}
\end{itemize}
Definitely need to know the answers to all 3 questions if you're writing a compiler or your own language.
\subsubsection{Syntactically Legal Expressions}
\label{sec:orgc11a6ea}
Def. (Not the definition for Ocaml, but similar and essentially for a basic language)

The set of expressions is defined inductively by the following clauses
\begin{enumerate}
\item A number \(n\) is an expression
\item The booleans \texttt{true} and \texttt{false} are expressions.
\item If \(e_1\) and \(e_2\) are expressions, then \(e_1\) op \(e_2\) is an expression where \(op =\{+,=,-,*,<\}\)
\item If \(e\), \(e_1\) and \(e_2\) are expressions, then \texttt{if} \(e\) then \(e_1\) \texttt{else} \(e_2\) is an expression
\end{enumerate}
Example of legal expressions:
\begin{itemize}
\item \texttt{if 3 then 2+3 else 5}
\begin{itemize}
\item This is syntactically fine, but it's a type error
\end{itemize}
\end{itemize}
When we define languages, we typically have 3 stages: 
\begin{enumerate}
\item source -> lexer -> parser (syntax errors here)
\begin{itemize}
\item After parse, you have an abstract syntax tree
\item How do I read \texttt{3+2=7}? \texttt{(3+2)=7} or \texttt{3+(2=7)}?
\item The definition above is tree like (with the if statements)
\item We won't talk much about parsing and lexing, as most of that has been solved
\end{itemize}
\item -> type checker (if it exists, also type errors are here) -> interpreter \& evaluation (run-time errors/run time exceptions)
\end{enumerate}
\subsubsection{Backus-Naur Form (BNF)}
\label{sec:org42c7f60}
Alternative to the previous definition.

Operations op ::= \(+|-|*|<|=\)

Expressions \(e\) ::= \(n|e_1 \ op \ e_2 | true | false | if \ e \ then \ e_1 \ else \ e_2\)

\begin{enumerate}
\item Representation in OCaml
\label{sec:org7eb7385}
\begin{verbatim}
type primop = Equals | LessThan | Plus | Minus | Times

type exp = 
| Int of int (* 0 | 1 | 2 | ... *)
| Bool of bool (* true | false *)
| If of exp * exp * exp (* if e then e_1 else e_2 *)
| Primop of primop * exp list (*e_1 primop e_2 or primop e *)
\end{verbatim}
Example: 
\begin{itemize}
\item \texttt{if 3<0 then 1 else 0} is represented as \texttt{If (Primop (LessThan, [Int 3 ; Int 0]), Int 1, Int 0)}
\item \texttt{if true then 3} cannot be represented, no else
\end{itemize}
\end{enumerate}
\subsubsection{Evaluation}
\label{sec:org22877f4}
How to evaluate an expression?
\begin{itemize}
\item How to describe evaluation of expressions?
\item We want to say: "Expression \(e\) evaluates to a value \(v\)"
\item What are values?
\begin{itemize}
\item Values \(v\) ::= \(n | true | false\)
\end{itemize}
\end{itemize}
Definition

Evaluation of the expression \(e\) to a value \(v\) is defined inductively by the following clauses:
\begin{itemize}
\item A value \(v\) evaluates to itself.
\item If expression \(e\) evaluates to the value \texttt{true} and expression \(e_1\) evaluates to a value \(v\), then \texttt{if} \(e\) \texttt{then} \(e_1\) \texttt{else} \(e_2\) evaluates to the value \(v\).
\item If expression \(e\) evaluates to the value \texttt{false} and expression \(e_2\) evaluates to a value \(v\), then \texttt{if} \(e\) \texttt{then} \(e_1\) \texttt{else} \(e_2\) evaluates to the value \(v\).
\end{itemize}
Too verbose and doesn't even talk about primitive operators. Need more compact notation.

\(e \Downarrow v\) for "Expression \(e\) evaluates to value \(v\)"

Definition with new notation:

\(e \Downarrow v\) is defined inductively by the following clauses:
\begin{itemize}
\item \(v \Downarrow v\)
\item If \(e \Downarrow\) \texttt{true} and \(e_1 \Downarrow v\), then \texttt{if} \(e\) \texttt{then} \(e_1\) \texttt{else} \(e_2 \Downarrow v\)
\item If \(e \Downarrow\) \texttt{false} and \(e_2 \Downarrow v\), then \texttt{if} \(e\) \texttt{then} \(e_1\) \texttt{else} \(e_2 \Downarrow v\)
\end{itemize}

Turning informal description into a formal one
$$\frac{premise_1 \ \ldots \ premise_n}{conclusion}\text{name}$$
Read as: If \(premise_1\) and \(premise_2\) and \(\ldots premise_n\), then conclusion.

$$\frac{}{v \Downarrow v}\text{B-VAL}$$
$$\frac{e \Downarrow true \ e_1 \Downarrow v}{if \ e \ then \ e_1 \ else \ e_2 \Downarrow v}\text{B-IFTRUE}$$
$$\frac{e \Downarrow false \ e_2 \Downarrow v}{if \ e \ then \ e_1 \ else \ e_2 \Downarrow v}\text{B-IFFALSE}$$
Here we only talk about the good things, \texttt{true} or \texttt{false}. We don't define what would happen if \(e \Downarrow\) something else, like a number. Then we would raise not defined.
\section{Lecture 27 \textit{<2017-11-14 Tue>}}
\label{sec:orgf680a16}
\subsection{Designing our own language}
\label{sec:org1bd4513}
(Continuation from last class)

We transformed evaluation into a formal description with premises and a conclusion. Note that evaluation rules do not impose an order on the premises. This works if we don't have state.

Extending further:
\begin{itemize}
\item If \(e_1 \Downarrow v_1\) and \(e_2 \Downarrow v_2\), then \(e_1 \ op \ e_2 \Downarrow v\) where \(v = \overline{v_1 \ op \ v_2}\)
\item \(\frac{e_1 \Downarrow v_1 \ e_2 \Downarrow v_2}{e_1 \ op \ e_2 \Downarrow \overline{v_1 \ op \ v_2}}\) B-OP
\end{itemize}
How to use these rules?
\begin{itemize}
\item Example in slides
\end{itemize}

Our operational semantics (\(e \Downarrow v\)) is what we formalized.

Task: Implement a function \texttt{eval} that does what \(e \Downarrow v\) describes.
\begin{verbatim}
let rec eval e = match e with
| Int _ -> e
| Bool _ -> e
| If (e, e1, e2) ->
    (match eval e with
    | Bool true -> eval e1
    | Bool false -> eval e2
    | _ -> raise (Stuck "guard is not  bool"))
\end{verbatim}
\subsubsection{Why do we care about a formal description?}
\label{sec:orgaa78b3b}
\begin{itemize}
\item More compact
\end{itemize}
Establish properties and formal guarantees
\begin{itemize}
\item Coverage: For all expressions \texttt{e} there exists an evaluation rule.
\item Determinacy: If \(e \Downarrow v_1\) and \(e \Downarrow v_2\) then \(v_1=v_2\)
\item Value Soundness: If \(e \Downarrow v\) then \(v\) is a value.
\begin{itemize}
\item Should always return a value
\end{itemize}
\end{itemize}
\subsubsection{Advantages of an implementation}
\label{sec:orgb8c686a}
We can run it!
\subsubsection{Static Type Checking}
\label{sec:org7f56e43}
\begin{itemize}
\item Types approximate runtime behavior
\item Lightweight tool for reasoning about programs
\item Detect errors statically, early in the development cycle
\item Great for code maintenance
\item Precise error messages
\item Checkable documentation of code
\end{itemize}
How do we make types work?
\begin{itemize}
\item Types classify expressions according to the kinds of values they compute
\begin{itemize}
\item What are values though?
\begin{itemize}
\item Values v ::= n | true | false
\end{itemize}
\item Hence, there are only two basic types.
\begin{itemize}
\item Types T ::= int | bool
\item In OCaml -> ints, floats, functions, unit, ref, etc.
\end{itemize}
\end{itemize}
\end{itemize}
\begin{enumerate}
\item Types
\label{sec:orgccd403d}
e:T, expression \(e\) has type \(T\)

Def:
\begin{enumerate}
\item n : int
\item true : bool and false : bool
\item If e : bool and \(e_1:T\) and \(e_2:T\), then if \(e\) then \(e_1\) else \(e_2\) : \(T\)
\item If \(e_1\) : int and \(e_2\) : int, then \(e_1 + e_2\) : int
\item If \(e_1 : T\) and \(e_2 : T\), then \(e_1 = e_2\) : bool
\end{enumerate}
Can be converted to premises
\begin{itemize}
\item \(\frac{}{true:bool}\) T-T
\item \(\frac{}{false:bool}\) T-F
\item \(\frac{e_1:T \ e_2:T}{e_1 = e_2 : bool}\) T-EQ
\item \(\frac{}{n:int}\) T-NUM
\item \(\frac{e_1:int \ e_2:int}{e_1+e_2:int}\) T-PLUS
\item \(\frac{e:bool \ e_1:T \ e_2:T}{if \ e \ then \ e_1 \ else \ e_2:T}\) T-IF
\end{itemize}

Two readings of typing
\begin{itemize}
\item Type Checking \(e:T\)
\begin{itemize}
\item Given the expression \(e\) and the type \(T\), we check that \(e\) does have type \(T\)
\end{itemize}
\item Type Inference \(e:T\)
\begin{itemize}
\item Given the expression \(e\), we infer its type \(T\)
\end{itemize}
\item OCaml does both and well
\item Checking is difficult for us with T-EQ, we don't know what type \(T\) is.
\end{itemize}
\end{enumerate}
\subsection{Demo}
\label{sec:orga18f138}
\begin{verbatim}
(* Defining a new language in OCaml *)
type primop = Equals | LessThan | Plus | Minus | Times | Negate

type exp = 
  | Int of int (* 0 | 1 | 2 | ... *)
  | Bool of bool (* true | false *)
  | If of exp * exp * exp (* if e then e_1 else e_2 *)
  | Primop of primop * exp list (*e_1 primop e_2 or primop e *)

(* How to evaluate? *)
module Eval =
  struct
    open exp

    exception Stuck of string

    let evalOp op = match op with
      | (Equals, [Int i; Int i']) -> Some (Bool (i = i'))
      | (LessThan, [Int i; Int i']) -> Some (Bool (i < i'))
      | (Plus, [Int i; Int i']) -> Some (Int (i + i'))
      | (Minus, [Int i; Int i']) -> Some (Int (i - i'))
      | (Times, [Int i; Int i']) -> Some (Int (i * i'))
      | (Negate, [Int i]) -> Some (Int (-i))
      | _ -> None

    let rec eval e = match e with
      | Int _ -> e
      | Bool _ -> e
      | If (e, e1, e2) ->
	 (match eval e with
	  | Bool true -> eval e1
	  | Bool false -> eval e2
	  | _ -> raise (Stuck "guard is not  bool"))
	   (* Primitive operations *)
      | Primop (po, args) ->
	 let argvalues = List.map eval args in
	 (match evalOp (po, argvalues) with
	  | Some v -> v
	  | None -> raise (Stuck "wrong arguments passed to prim. op"))

  end
    (* The rest is on course page *)
\end{verbatim}
\end{document}